
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@malwareunicorn">
  <meta name="twitter:creator" content="@malwareunicorn">
  <meta name="twitter:title" content="Reverse Engineering 102">
  <meta name="twitter:description" content="This workshop build on RE101 and focuses on identifying simple encryption routines, evasion techniques, and packing.">
  <meta name="twitter:image" content="https://malwareunicorn.org/re102/img/94120421e2e9d5d5.png">
  <title>Reverse Engineering 102</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="../pkg/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
  <script src="../gif/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../gif/gif-player.es5.js" defer async></script>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="re102"
                  title="Reverse Engineering 102"
                  environment="web"
                  feedback-link="">

      <google-codelab-step label="Introduction" duration="1">
        <p>This workshop provides builds on the fundamentals from re101 for reversing engineering (RE) Windows malware using a hands-on experience with RE tools and techniques. The purpose of this workshop is to get you familiar with Anti Reverse Engineering, Encryption, VM Evasion and Packing techniques.The course will conclude by participants performing hands-on malware analysis that consists of Triage, Static, and Dynamic analysis.</p>
<h2 is-upgraded>What you&#39;ll do</h2>
<p>Reverse engineer a real x86 windows malware binary.</p>
<h2 class="checklist" is-upgraded>What you&#39;ll learn</h2>
<ul class="checklist">
<li>Understand how Delphi application binaries are structured</li>
<li>Learn some evasion techniques (Anti-Re, Anti-Automation, Anti-VM)</li>
<li>Learn how to identify an encryption algorithm</li>
<li>Execute an assembly program using the Unicorn Engine</li>
<li>Identify a custom packing technique</li>
<li>Narrow down specific information and indicators before moving on to deeper static and dynamic analysis.</li>
<li>How to jump into code in static disassembly then rename and comment on interesting assembly routines that you will debug.</li>
<li>Deeper analysis of the program to understand hidden functionality not understood statically.</li>
</ul>
<h2 is-upgraded>What you&#39;ll need</h2>
<ul>
<li>At least 8 GB of RAM</li>
<li>At least 20 GB of storage</li>
<li>Internet connection</li>
<li>Virtual Machines from RE101</li>
</ul>
<h2 is-upgraded>Analysis Flow for Malware Analysis</h2>
<ul>
<li>Setup a baseline analysis environment</li>
<li>Triage to determine a starting point</li>
<li>Static Analysis - Get a sense of where everything is before debugging</li>
<li>Dynamic Analysis - Determine behaviors that can&#39;t be understood by static analysis</li>
<li>Manual Debugging - Stepping through the program to navigate to your goals</li>
</ul>


      </google-codelab-step>

      <google-codelab-step label="Environment Setup" duration="120">
        <p>If you haven&#39;t already, please take the <a href="https://malwareunicorn.org/workshops/re101.html" target="_blank">RE101</a> workshop. The environment setup is the same. </p>
<h2 is-upgraded>Download the Unknown Malware</h2>
<aside class="warning"><p>Download the binary for this Lab: <a href="https://malwareunicorn.azureedge.net/mucontainer/8be8abab0f3ebcc18e7b8b3c437feb073fa7b9b30e8b1eef81451f0938b2a52a.zip.7z" target="_blank"><paper-button class="colored" raised><iron-icon icon="file-download"></iron-icon>Download Malware Zip</paper-button></a></p>
<p>password: infected</p>
<p><strong>WARNING - DO NOT UNZIP OR RUN THIS OUTSIDE OF A NETWORK ISOLATED VM</strong></p>
</aside>
<h4 is-upgraded>Sha1 for 7z file</h4>
<pre><code>bf0104e33909197ed7b98410c93e81430e67950c</code></pre>
<h4 is-upgraded>Sha256 Malware inside</h4>
<pre><code>8be8abab0f3ebcc18e7b8b3c437feb073fa7b9b30e8b1eef81451f0938b2a52a</code></pre>
<ol type="1" start="1">
<li>Run the Victim VM and copy over the malware.zip into the VM.</li>
<li>Unzip Warning - DO NOT UNZIP THIS OUTSIDE OF THE VM</li>
</ol>


      </google-codelab-step>

      <google-codelab-step label="Information Gathering Exercise" duration="20">
        <p>You want to find as much information as you can before you begin the static and dynamic analysis.</p>
<p>As mentioned in RE101, please collect the information in this checklist. You can do this list in any order.</p>
<ul>
<li>File Context and Delivery</li>
<li>File Information &amp; Header Analysis</li>
<li>Get Basic PE information</li>
<li>Collect Strings</li>
<li>Simple Web Search</li>
<li>Check AV vendors</li>
<li>Quick VM Detonation</li>
<li>Capture network information</li>
</ul>
<p>The next page will reveal the information you need.</p>


      </google-codelab-step>

      <google-codelab-step label="Information Gathering Results" duration="5">
        <p>I personally just start by looking up the hash on <a href="https://www.virustotal.com/" target="_blank">VirusTotal</a> because most of the triage information is already there. If it&#39;s not on VirusTotal, there are tools in the VMs. You can get the same information by using CFF explorer.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/701054c06edb23a1.png"></p>
<h2 is-upgraded>File Context and Delivery</h2>
<p>We don&#39;t have a victim to tell us how this file was delivered. However you can guess the intent by looking at the original filename in the properties <strong>InternalName</strong> and<strong> FileDescription</strong>. As you can see it is posing as the <strong>Anti-Virus Malwarebytes</strong> software. One can only guess that the malware was pretending to be an Anti-Virus so that the victim will trust it. An IT admin might even overlook the process with the name mbam.exe because it will look legit at first glance.</p>
<p class="image-container"><img style="width: 362.00px" src="../re102/img/726d9295dfe475fa.png"></p>
<h2 is-upgraded>File Information &amp; Header Analysis</h2>
<p>We already know that this sample is posing as Anti-Virus Software. How do we know it&#39;s not legit? Because we know that this sample is <strong>not signed</strong> at all or <a href="https://en.wikipedia.org/wiki/Code_signing" target="_blank"><strong>signed</strong></a> by MalwareBytes the company. So that is already a major Red Flag.</p>
<p>Notice that the file size is pretty small, 2.1 MB. Legitimate executables are usually much larger because they have many libraries to ensure that the program has enough resources and support for different execution environments. This file is actually larger than normal malware because of the resource sections, which I will get into later.</p>
<h2 is-upgraded>Basic PE information</h2>
<p>As I explained above, the file size is small but still larger than most malware. That&#39;s because 2 reasons:</p>
<ol type="1" start="1">
<li>It has many resources</li>
<li>It was compiled as <strong>Borland Delphi</strong> (<code>BobSoft Mini Delphi -&gt; BoB / BobSoft</code>).</li>
</ol>
<p>Why does it matter how the sample was compiled? Because it will determine how the disassembly will be structured.</p>
<p>There are all different types of programming languages, and each with their supporting libraries. The more high-level language such as C#, Python, Delphi the more libraries they need to support transposing the language in to assembly code. This info will become more important when you look at its disassembly.</p>
<h2 is-upgraded>Imports</h2>
<p>Dynamic Linked Library (DLL) Imports are great way to guess what a malware is going to do. Looking at the imported functions for <code>User32.dl</code>l you can see there are many API functions related to User Interaction (i.e. <code>GetForegroundWindow,</code> <code>GetCursorPos</code>, etc.). While in Kernel32.dll, there are many functions for memory manipulation (i.e <code>VirtualAlloc, VirtualFree</code>), resource manipulation (i.e. <code>FindResourceA, SizeofResource</code>), and possible Anti-Analysis tricks (i.e.<code>Sleep, GetTickCount</code>). With the imports from <code>Advapi32.dll</code>, we can tell it is going to access registry keys (i.e. <code>RegOpenKeyExA</code>). The more malware you examine, the more you will get use to seeing how they API functions are being used.</p>
<h2 is-upgraded>Strings Review</h2>
<p>Strings always provide a good starting point for clues. It may also reveal things that the PE info was not able to provide such as extra loaded DLLs and API functions. Another hint is looking at junk strings. Junk strings potentially means it is either an image or extra binary data being reference by the sample. It could potentially be an encoded/encrypted/compressed payload. (muhahaha)</p>
<p class="image-container"><img style="width: 233.00px" src="../re102/img/5215697bcd944dad.png"></p>
<h2 is-upgraded>Web search</h2>
<p>A string web search is a last resort. I usually use this step to find reports already generated for this family of malware. Unfortunately there is a ton of junk data, so we can assume this sample might be packed/encrypted somehow for now.</p>
<h2 is-upgraded>Anti-Virus Vendors</h2>
<p>AV Vendors provide some insight into a sample besides just good or bad. There are also many heuristic and generic detections that might not be useful in telling you what the sample is going to do. Keywords like Trojan or GEN for Generic are not enough to tell you how bad it is. However the keyword Injector gives us a hint that it is doing some kind of code in memory manipulation. As we know from above, this malware has a bunch of junk code, so AV might not have enough binary features to make a definitive signature but still does well in telling you that it looks generally abnormal.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/90275a097d9bb39a.png"></p>
<h2 is-upgraded>VM Detonation &amp; Network Information</h2>
<p>If you followed RE101 Lab 1 you will know how to do a simple VM detonation to collect the filesystem, process, registry and network information. You will notice that this sample does nothing really special in the VM. So we will need to investigate why.</p>


      </google-codelab-step>

      <google-codelab-step label="Creating Travel Directions" duration="3">
        <p>Now it&#39;s time for static analysis by looking at the disassembly. The point of this section is to create a map of the execution flow of the malware. The easiest way to accomplish this is by starting somewhere in the middle and then working your way backwards. Working backwards helps you create a more accurate route because you can see the forks that led to your current position. You can anticipate the right or left path, in assembly, it&#39;s jump or not-to-jump.</p>
<p>Starting somewhere in the middle means picking an interesting function to look at or where a string is referenced. Many malware reverse engineers want to start at interesting API functions like the imports mentioned in the previous section.</p>
<h2 is-upgraded>Understanding Post-Compiled Structure</h2>
<p>Remember that this sample is Borland Delphi code. This means we will see many functions building up the Delphi libraries. These libraries are organized like object-oriented classes. Each class has an initialization function as well as references to class functions. A Delphi app will sequentially load these structures where libraries are loaded before the main function coded by the malware author. Makes sense, right? In order to use the library, you have to load them first.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/2870296552c6a471.gif"></p>
<p>The diagram above is a high-level view of how a Delphi app executes each library class. There is a pointer to a hardcoded array/list of these classes which is passed to InitExe function and then the StartExe function. It will loop through this list initializing, executing, and storing pointers to functions for later use. I have identified Main Functions as the possible interesting functions we want to look at. The disassembly equivalent of the diagram is below.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/cdc0b7232b83ea32.png"></p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/2c12576b92a2faa6.png"></p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/dff0f1c541cd6b0a.png"></p>
<h2 is-upgraded>Where to Start?</h2>
<p>So we have some options to start working backwards:</p>
<ol type="1" start="1">
<li>Where was that junk data was referenced.</li>
<li>Choose an import function (i.e <code>VirtualAlloc</code>).</li>
<li>Choose a function that is not loading a library.</li>
</ol>
<p>So the goal here is making the route between the StartExe and choices 1,2, or 3. So let&#39;s pick option 1 and start Lab 1 on the next page.</p>


      </google-codelab-step>

      <google-codelab-step label="Lab 1 Static Analysis" duration="15">
        <p>Go ahead and open IDAfree and load the malware. Give IDA some time to parse all of the functions. It should begin the analysis in the start function. If you are not in the start function, select the start function from the function tab/window.</p>
<h2 is-upgraded>Identifying Delphi</h2>
<p>The previous page talked about the delphi structure. You should be able to identify the InitExe and the array of classes at offset dword at <code>0045BB5C</code>. Double-click on offset <code>dword_45BB5C</code>. Notice that this looks like the array discussed on the previous page.</p>
<aside class="special"><p><strong>Note:</strong> IDAPro provides better delphi library support and will automatically name library references for you.</p>
</aside>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/129564aa30e8ca38.gif"></p>
<h2 is-upgraded>Junk Data</h2>
<p>In the information gathering stage, the strings revealed that there was some junk data being referenced. Let&#39;s actually look how those strings are being referenced in the disassembler. Scroll down until you see some junk strings in the DATA section in the IDA Strings panel. Each Portable Executable (PE) section has its own purpose. The DATA (.data) section is typically used for hardcoded global and static variables that are initialized at compile time [1]. This section is more commonly used for storing string references. To see a string referenced in the data section that looks like junk data might be an indicator of foul play.</p>
<p class="image-container"><img style="width: 278.00px" src="../re102/img/fa316bf03f9949d1.png"></p>
<h2 is-upgraded>Follow the Junk Data</h2>
<p>Double-Click the first instance of the junk data. At this point is should show you the location in the IDA View. Scroll up until you see a <code>unk</code> reference to the start of this data. It should say <code>unk_45CCD4</code>. You want to follow this reference in the code by selecting and then press ‘x&#39; to open the xrefs menu. This menu shows all the functions and locations that reference the object. Select the only function present and press ok.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/129564aa30e8ca38.gif"></p>
<p>IDA should have landed you in the function that is using this data. Notice anything fishy about this function?</p>
<p class="image-container"><img style="width: 200.00px" src="../re102/img/27fe24744ab72f93.jpeg"></p>
<p>It&#39;s calling <code>VirtualAlloc</code>.</p>
<p>So you see that VirtualAlloc with size <code>0x65E4</code> hex which is 26,084 bytes decimal. The junk data pointer (labeled Junk 2) is about to be used by function <code>sub_407074</code>. Normally when you see a function following VirtualAlloc, it will copy data into the newly created memory location. You should record the contents of Junk 1 because you will need this dword value later. Finally rename function <code>sub_407074</code> to something like &#34;copy_to_new_mem&#34;.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/57565c48718d6bbd.png"></p>
<h2 is-upgraded>Trace Backwards</h2>
<p>So now you want to find the route between the<strong> start </strong>function and our renamed function <strong>copy_to_new_mem</strong>. By using xrefs (selecting &amp; pressing x) you can follow all the functions that referenced the function you selected. Scroll up to the top of the functions and see if you can work your way back to the delphi class library array.</p>
<p>Your notes should be something like this:</p>
<p><code>Copy_to_new_mem &lt;- sub_45B794 &lt;- sub_45B894 &lt;- sub_45B93C &lt;- 045BB5C (Array)</code></p>
<p>Renaming each to something notable like:</p>
<p><code>Copy_to_new_mem &lt;- use_junkdata &lt;- before_use_junkdata &lt;- main_function &lt;- 045BB5C (Array)</code></p>
<p>Keeping track of this route by the function offset (e.g. <code>0045B93C</code>) allows you to set breakpoints when you start debugging. You know ahead of time where you want to navigate to.</p>
<h2 is-upgraded>Recording Control Flow</h2>
<p>IDA does a lovely job of showing you green and red arrows for control flow instructions in the assembly. You will want to keep track of instructions like cmp, jmp, jnz, jz, jl, jnb, etc. that affect the route. Recording these locations will come in handy when you start debugging and need to manipulate EFlags to change the decision of the jump.</p>
<h2 is-upgraded>Record Anything Interesting</h2>
<p>As you are building your route, any API call or string is helpful in identifying the purpose of a function. You may change the name of the function depending on what new information you find. For instance, <code>sub_45B93C</code> (a.k.a. main_function) is doing an interesting routine. Can you guess why this function is using GetForegroundWindow, Sleep, then GetForegroundWindow? If not, record and save it for later. These routines may affect the control flow instructions. The example below shows how the success or failure of OutputDebugStringA is compared using <code>cmp esi,ebx</code> while <code>jz</code> will jump if the result of the comparison is equal to zero. During debugging you may want to manipulate the EFlags so that it will not jump.</p>
<p class="image-container"><img style="width: 342.00px" src="../re102/img/3bdf515ada433fef.png"></p>
<h2 is-upgraded>Work on Your Own</h2>
<p>Take this time to make some nice travel directions. The next page will have what your directions should look like.</p>


      </google-codelab-step>

      <google-codelab-step label="Lab 1 Results" duration="2">
        <ol type="1" start="1">
<li>Start</li>
<li><code>sub_406604</code> - Step into InitExe</li>
<li><code>sub_403FA0</code> - Step into StartExe</li>
<li><code>sub_403F40</code> - Step into This loops through the static list of functions in the references until the main function <code>sub_45B93C</code></li>
<li><code>sub_45B93C</code> - Checks to see if the foreground window has changed</li>
</ol>
<ul>
<li>First it will get the foreground window, then sleep for 64h then capture the foreground window again</li>
<li><code>0045B991</code> - jz should not jump</li>
</ul>
<ol type="1" start="6">
<li>It then tries to check for debug output using string &#34;w4ZUHcHjWZiye735mOUvnkKZ6XwjXIlyrS&#34;</li>
</ol>
<ul>
<li><code>0045B9C1</code> - jl should jump</li>
<li><code>0045B9CB</code> - jnz should not jump</li>
</ul>
<ol type="1" start="7">
<li>Tries to unsuccessfully load dll AXLzZmdD9HtbQccvaUl8.dll</li>
</ol>
<ul>
<li><code>0045B9D9</code> - jnz should not jump</li>
<li><code>0045B9DE</code> - jnz should not jump</li>
</ul>
<ol type="1" start="8">
<li>Tries to find Atom RkLNPKJEBsQUb</li>
<li><code>sub_45B894</code> - Step into before_use_junkdata</li>
</ol>
<ul>
<li><code>GetConsoleCP</code> - Retrieves the input code page used by the console associated with the calling process. A console uses its input code page to translate keyboard input into the corresponding character value.</li>
<li><code>0045B89F</code> - jz should not jump</li>
<li>Loops for <code>0x355aef09</code> times for no reason. Kill the loop by <code>0045B8AD</code> jnz to not jump.</li>
<li><code>0045B8C4</code> - jnz should not jump</li>
<li>Loops for <code>0x5A73350</code> times for no reason. Kill the loop by setting jnz to not jump.</li>
</ul>
<ol type="1" start="10">
<li><code>sub_45B794</code> - Step into use_junkdata</li>
</ol>
<ul>
<li>VirtualAlloc new memory with the size of 0x65E4</li>
<li>Nop instructions indicate foul play</li>
<li><code>dword_45CCB0</code> value is <code>0x42B7</code></li>
<li><code>unk_45CCD4</code> is the Junk data</li>
<li><code>sub_407074</code> - Step over Copy_to_new_mem, loads Junk data of size <code>0x65E4</code> into new memory: Delphi move(source, dest);</li>
<li><code>unk_45CCB4</code> - loads 0x20 byte string</li>
<li><code>sub_45B5AC</code> - do_something_interesting( size of junk data, size of 0x20 byte string, pointer to 0x20 byte string, 0x100, <code>0x0BEE2</code>, pointer to newly copied memory of junk data)</li>
</ul>
<p>Let&#39;s save <code>sub_45B5AC</code> for the next section.</p>


      </google-codelab-step>

      <google-codelab-step label="Lab 2 Identifying Encryption" duration="15">
        <p>This section will focus on generically recognizing encryption routines. In the previous section, you left off at <code>sub_45B5AC</code>. As you might be able to guess, this malware is using an encryption algorithm here. The giveaways are:</p>
<ul>
<li>Suspicious function arguments (e.g., large amounts of bytes used for allocation)</li>
<li>Multiple loops</li>
<li>Usage of XOR</li>
<li>Unusual instructions (e.g., NOP)</li>
</ul>
<h2 is-upgraded>Suspicious Function Arguments</h2>
<p>To decrypt data that is encrypted the malware needs:</p>
<ol type="1" start="1">
<li>Key</li>
<li>Encrypted Data (a.k.a ciphertext)</li>
<li>Destination for Decrypted Data</li>
</ol>
<p>Let&#39;s take a look at the arguments for <code>sub_45B5AC</code>. In the image below, you can see it&#39;s pushing 4 times and saving 3 objects in 3 different registers (ecx, edx, eax).</p>
<aside class="special"><p><strong>Note: </strong>In RE 101, it explained that assembly function calls have their arguments pushed onto the stack in reverse order. To learn about the reason behind this you can check out this article.</p>
</aside>
<p class="image-container"><img style="width: 553.00px" src="../re102/img/97777e95f2738543.png"></p>
<h2 is-upgraded>Delphi calling convention</h2>
<p>Remember that this is delphi so the calling convention uses registers eax, ecx, edx as first 3 arguments. The rest of the arguments are pushed on stack in reverse order.</p>
<pre><code>push    3
push    4
mov     ecx, 2
mov     edx, 1
xor     eax, eax
call    function
xor     eax,eax
retn    10</code></pre>
<p>Based on previous sections, it should be already obvious to you what these values mean. You know that the malware recently called VirtualAlloc, and moved junk 2 of size 0x65E4 into the new memory stored it in <code>[ebp+var_BEEB]</code>. If you click on <code>unk_45CCB4</code>, you will see that this data is only 0x20 (32 dec) bytes. So, the pseudo code for this function would be:</p>
<pre><code>eax = size_of_junk2
edx = size_of_small_junk
ecx = small_junk unk_45CCB4
sub_45B5AC( 0x100, 0xBEE2, junk2, 0x1F) </code></pre>
<p>Let&#39;s rename it all:</p>
<pre><code>eax = data_size
edx= key_size
ecx = key
decrypt(0x100, 0xBEE2, encrypted_data, 0x1F)</code></pre>
<p>Now all you need to know is what 0x100 and 0xBEE2 represent, and you might not know until you start to break down the decrypt function.</p>
<aside class="special"><p><strong>Note: </strong> 0xBEE2 is 48,866 bytes. This is large enough to be a new executable.</p>
</aside>
<h2 is-upgraded>Multiple Loops</h2>
<p>Cryptographic algorithms are often grouped into two major categories: symmetric and asymmetric. Most of these algorithms in order to perform some sort of shuffling to the plaintext need to loop over each or blocks of characters. Let&#39;s take a look at a structure used in many symmetric block cipher algorithms:</p>
<p class="image-container"><img style="width: 389.63px" src="../re102/img/f21c3da11b962737.png"></p>
<p>For every subkey K in this algorithm, it has to loop through each K to XOR and Swap. In the disassembly you will be able to see this looping, incrementing, and swapping action going on. Now let&#39;s look at <code>sub_45B5AC</code>.</p>
<p class="image-container"><img style="width: 457.00px" src="../re102/img/bfeef8d5e848a9e5.png"></p>
<p>There are actually multiple loops happening in this function. The next section will go over how identifying this algorithm. This section focuses on just recognizing usage of crypto.</p>
<h2 is-upgraded>Usage of XOR</h2>
<p>Bitwise operator, XOR, is the most basic of symmetric key encryption algorithms. Like in the block cipher algorithm above the circle with a cross inside represents the XOR symbol. When reversing assembly code to identify the usage of cryptographic algorithms, you typically want to look for XOR instruction with 2 different registers.</p>
<aside class="special"><p><strong>Note: </strong>Do not mistake instructions such as xor eax, eax for usage of crypto, because they are usually used for clearing out a register (e.g., eax in this case).</p>
</aside>
<p>In function <code>sub_45B5AC</code>, <code>xor [esi], al</code>, is another nice indicator of encryption usage.</p>
<h2 is-upgraded>Suspicious Instructions</h2>
<p>In the beginning of this section, it mentioned you need to be suspicious of NOP instructions; however, they are not indicators for usage of cryptographic algorithms. They usually show that the malware author did not want the function to be analyzed or detected. Inserting NOPs changes the patterns of the bytecode of a binary, and makes it harder for AV&#39;s signatures to detect those patterns. As an analyst, when I see these NOPs, I can usually tell that I am in the right spot (or a spot that the malware author does not want me to be), so I will start digging deeper.</p>
<p>The next subsection will go over identifying which cryptographic algorithm this malware is using.</p>


      </google-codelab-step>

      <google-codelab-step label="Lab 2 Identifying the Decryption Algorithm" duration="15">
        <p>Now it&#39;s time to dig deeper and follow the assembly one step at a time. From the previous page you recorded what are the arguments and variables used in function <code>sub_45B5AC</code>:</p>
<pre><code>eax = data_size
edx= key_size
ecx = key
sub_45B5AC( 0x100, 0xBEE2, junk2, 0x1F)</code></pre>
<p>Now that you are in the <code>sub_45B5AC</code> function, IDA labels the arguments as:</p>
<pre><code>Arg_0 = 0x100
Arg_4 = 0xBEE2
Arg_8 = junk2
Arg_C = 0x1F</code></pre>
<p>At <code>loc_45B5C9</code>, the registers that saved the key and sizes are moved into base pointer offsets:</p>
<pre><code>45b5cb:    mov [ebp-0xc], ecx ; Key
45b5ce:    mov [ebp-0x8], edx ; Size of Key
45b5d1:    mov [ebp-0x4], eax ; Size of Shellcode</code></pre>
<aside class="special"><p><strong>Note: </strong>Remember the stack structure from RE101, local variables grow to lower addresses and parameters grow to higher addresses</p>
<p class="image-container"><img style="width: 490.50px" src="../re102/img/3e19937480afec79.png"></p>
</aside>
<p>Now that you have all the important variables, you can statically trace through this function in IDA to discover it&#39;s algorithm.</p>
<h2 is-upgraded>Loop 1: Saving the Key on the Stack</h2>
<p>Arg_C is <code>0x1F</code> (31 dec) bytes, which is one byte less than the size of our key. Since arrays start from 0, as you can guess this represents <code>key_size-1</code>. This gets saved into register <code>ebx</code></p>
<p class="image-container"><img style="width: 366.00px" src="../re102/img/94120421e2e9d5d5.png"></p>
<p>If you are not familiar with mathematical equivalent of bitwise operations, it is important to know shift operations can be a form of multiplication or division. For example, when you see <code>shr ebx, 2</code>, it means that the content of the ebx register is getting divided by 4. This is 31 divided by 4. Why 4? Because when you shift n bits of an unsigned binary number, it has the effect of dividing it by 2^n (rounding towards 0). As it loops through the Key (ecx) is pushes/saves 4 byte chunks onto the stack. It should look something like this:</p>
<pre><code>00183BCC  3669C7AF
00183BD0  CBD60266
00183BD4  0C33A849
00183BD8  973AD4C1
00183BDC  C868B780
00183BE0  820B3D00
00183BE4  2C9BED2C
00183BE8  F94D125D </code></pre>
<h2 is-upgraded>Loop 2: Fill the Stack 0x100 characters</h2>
<p>This next loop fills the stack starting at <code>[ebp+var_418]</code>. It loops for 0x100 times or 256 decimal while incrementing ebx from 0 to 255.</p>
<p class="image-container"><img style="width: 330.00px" src="../re102/img/fa585192e81caaab.png"></p>
<p>At this stage the question that you need to ask yourself is what crypto algorithm uses 256 bytes with a key size of 32 bytes? You can also even narrow it down to only symmetric key algorithms, since this function is way too simple be an asymmetric key algorithm.</p>
<p>So let&#39;s create the pseudo code for this loop:</p>
<pre><code>int ebx = 0;
int length = 256 // 0x100
While (ebx &lt; 256)
{
    push(ebx)
    ebx++
}</code></pre>
<p>This is what the stack should look like:</p>
<p class="image-container"><img style="width: 512.00px" src="../re102/img/5d1d2a2f042dd429.png"></p>
<h2 is-upgraded>Loop 3: Functions applied to 0x100 characters</h2>
<p>In the same location on the stack [ebp+var_418], the loop processes the data again, but introduces the usage of function <code>sub_405268</code>. This function takes 3 inputs.</p>
<p>The first call to <code>sub_405268</code>:</p>
<ol type="1" start="1">
<li>0</li>
<li>[ebp-0x8] Size of Key which is 32 decimal</li>
<li>eax</li>
</ol>
<p>The second call to <code>sub_405268</code>:</p>
<ol type="1" start="1">
<li>0</li>
<li>Arg_0 which is 0x100, 256 decimal</li>
<li>eax</li>
</ol>
<p class="image-container"><img style="width: 319.00px" src="../re102/img/845e29a1a581c35d.png"></p>
<p>When you enter function <code>sub_405268</code>, you will notice that there are a bunch of arithmetic instructions. This function is actually a modulo function. </p>
<aside class="special"><p><strong>Note: </strong>The Pro version of IDA marks function <code>sub_405268</code> as the Delphi library function System::llmod.</p>
</aside>
<p>Rename function <code>sub_405268</code> to &#34;mod&#34;.</p>
<p>At the end of the loop, the are some move instructions. Can you guess what is going on here?</p>
<ul>
<li><code>ebx</code> is being incremented by 1, let ebx be i where i = 0</li>
<li><code>esi</code> is being incremented by 4, in other words let esi be j where j = 0.</li>
<li><code>[ebp+var_418]</code> is the location of the 0-256 characters created, let it be array[]</li>
<li><code>ebp+var_C</code> is the pointer to the Key</li>
<li><code>ebp+var_D</code> is a temporary location on the stack</li>
</ul>
<p>So let&#39;s make the pseudo code for this loop:</p>
<pre><code>int i = 0; //eax
int j = 0;
int temp, a, b, c;
while (i &lt; 0x100)
{
    i = mod( 0, 0x20, i );
    a = Key[ i ]; // eax, [edx+eax]
    b = j+Array[i]; // edi, [esi]
    c = a+b; // add eax, edi
    j = mod (0, 0x100, c);

    //swap
    temp = Array[i];
    Array[i] = Array[j];
    Array[j] = temp;
    i++;
}</code></pre>
<p>Let&#39;s see if you can identify this crypto algorithm. Try google searching for &#34;symmetric mod 256&#34;. Your first hit might be RC4 from wikipedia.</p>
<p class="image-container"><img style="width: 200.00px" src="../re102/img/27fe24744ab72f93.jpeg"></p>
<p>Check out that Key-scheduling algorithm on the RC4 wikipedia page. Notice any similarities from Loop 2 and Loop 3?</p>
<p class="image-container"><img style="width: 450.00px" src="../re102/img/fed740e47853f380.png"></p>
<h2 is-upgraded>Loop 4: Loop through Junk2 data</h2>
<p>Looks like this algorithm is RC4 256. On your own, try to trace through the second part of the RC4 algorithm with the fourth loop. Be extra careful in assigning the variables, because there is an error here and you may not find it right away until you start decrypting.</p>


      </google-codelab-step>

      <google-codelab-step label="Lab 3 Writing a Decryptor" duration="20">
        <h2 is-upgraded>The Return Address</h2>
<p>Before we begin to decrypt the Junk2 data, you need to know where our decrypted junk2 will be located at. Let&#39;s go back to the subroutine that calls the decryption function in <code>sub_45B794</code>. Remember that DWORD that you saved earlier in the road map? The value <code>0x4B27</code> was added to the address of the newly allocated memory (i.e., the return value of VirtualAlloc).. This value Offset+0x4B27 is being saved in register esi and then pushed onto the stack before the function returns. Typically functions will pop the <code>ebp</code> on the stack to restore the previous stack frame of the calling function. Here the eip will return to Offset+42B7 which is where our decrypted junk2 data will be.</p>
<p>You should recognize that the malware plans to execute the encrypted Junk2 data here. Now you know the purpose of the Junk2 data which is Position Independent Code (PIC) more typically known as Shellcode.</p>
<p class="image-container"><img style="width: 393.00px" src="../re102/img/b67ca0eaee06e320.png"></p>
<h2 is-upgraded>Export the Key and Shellcode</h2>
<p>In order to extract the shellcode and the key from the malware you will use the HxD hex editor.</p>
<p>In IDA, select the shellcode (labeled as <code>unk_45CCD4</code>) with starting offset of <code>0x5BED4</code>. From previous sections, we know that the size of this data is 0x65E4. Open the mbam.exe with HxD and choose Edit-&gt;Select Block. Plug in the offset and length.</p>
<p class="image-container"><img style="width: 241.00px" src="../re102/img/e36685cfc2d38dcb.png"></p>
<p>Copy and save these bytes into a new binary file in HxD hex editor and name it shellcode.bin.</p>
<p>Again, in addition to extracting the shellcode, you need to extract the key as well. So, do the same for the key offset and name it as key.bin.</p>
<h2 is-upgraded>RC4 Decrypt Script</h2>
<p>Let&#39;s code the RC4 key scheduling and pseudo-random generation algorithm algorithm in Python based on the pseudo code given below:</p>
<h3 is-upgraded>Key Schedule Pseudo Code <a href="https://en.wikipedia.org/wiki/RC4#Key-scheduling_algorithm_.28KSA.29" target="_blank">1</a></h3>
<pre><code>for i from 0 to 255
    S[i] := i
endfor
j := 0
for i from 0 to 255
    j := (j + S[i] + key[i mod keylength]) mod 256
    swap values of S[i] and S[j]
endfor</code></pre>
<h3 is-upgraded>Pseudo-random generation algorithm (PRGA) <a href="https://en.wikipedia.org/wiki/RC4#Pseudo-random_generation_algorithm_.28PRGA.29" target="_blank">2</a></h3>
<pre><code>i := 0
j := 0
while GeneratingOutput:
    i := (i + 1) mod 256
    j := (j + S[i]) mod 256
    swap values of S[i] and S[j]
    K := S[(S[i] + S[j]) mod 256]
    output K
endwhile</code></pre>
<h3 is-upgraded>Python Code</h3>
<p>Here is the python code that mirrors the pseudo code above.</p>
<pre><code>import os
import sys


def key_schedule(key):
    keylength = len(key)
    S = range(256)
    j = 0
    for i in range(256):
        k = ord(key[i % keylength])
        j = (j + S[i] + k) % 256
        S[i], S[j] = S[j], S[i]  # swap
    return S


with open(sys.argv[1], &#39;rb&#39;) as key_file, open(sys.argv[2], &#39;rb&#39;) as encrypted, open(&#34;decrypted_shellcode.bin&#34;, &#39;wb&#39;) as out:
    key_size = os.path.getsize(sys.argv[1])  # 0x20
    key = key_file.read(key_size)
    S = key_schedule(key)

    j = 0
    i = 0

    shellcode_size = os.path.getsize(sys.argv[2])  # 0x65E4

    while (shellcode_size &gt; 0):
        char = encrypted.read(1)
        i = (i + 1) % 256
        j = (j + S[i]) % 256

        # swap
        S[i], S[j] = S[j], S[i]
        k = S[(S[i] + S[j]) % 256]
        shellcode_size -= 1

        out.write(chr(ord(char) ^ k))
    out.close()
    key_file.close()
    encrypted.close()</code></pre>
<h2 is-upgraded>Error in the Malware&#39;s Decryption Algorithm!</h2>
<p class="image-container"><img style="width: 500.00px" src="../re102/img/233c5c6d4af544f4.gif"></p>
<p>If you run the script above against the extracted data, the decrypted data will not make a lot of sense.This is mainly because there is an error in the RC4 algorithm implemented by the malware author. If you pay attention to disassembled code in IDA, you will see between Loop 3 and Loop 4 the register that stores the j variable was never reseted after the key schedule is made.</p>
<h2 is-upgraded>Run the Correct Decrypt Algorithm</h2>
<p>This python script has the correct decryption algorithm. You can name it &#34;decrypt_shellcode.py&#34;</p>
<pre><code>import os
import sys

def key_schedule(key):
    keylength = len(key)
    S = range(256)
    j = 0
    for i in range(256):
        k = ord(key[i % keylength])
        j = (j + S[i] + k) % 256
        S[i], S[j] = S[j], S[i]  # swap
    return S, j


with open(sys.argv[1], &#39;rb&#39;) as key_file, open(sys.argv[2], &#39;rb&#39;) as encrypted, open(&#34;decrypted_shellcode.bin&#34;, &#39;wb&#39;) as out:
    key_size = os.path.getsize(sys.argv[1])  # 0x20
    key = key_file.read(key_size)
    S, j = key_schedule(key)

    &#34;&#34;&#34;
    A normal RC4 stream algorithm
    resets j before a second use.
    &#34;&#34;&#34;
    # j = 0

    i = 0

    shellcode_size = os.path.getsize(sys.argv[2])  # 0x65E4

    while (shellcode_size &gt; 0):
        char = encrypted.read(1)
        i = (i + 1) % 256
        j = (j + S[i]) % 256

        # swap
        S[i], S[j] = S[j], S[i]
        k = S[(S[i] + S[j]) % 256]
        shellcode_size -= 1

        out.write(chr(ord(char) ^ k))
    out.close()
    key_file.close()
    encrypted.close()</code></pre>
<p>In the Victim VM, open up the command prompt and run the following line. Replace location to the folder you stored the bin files and script.</p>
<pre><code>c:\Python27\python.exe &lt;location&gt;\decrypt_shellcode.py  &lt;location&gt;\key.bin  &lt;location&gt;\shellcode.bin</code></pre>
<p>Now that you have the decrypted shellcode let&#39;s turn it into an exe so you can analyze it in IDA. The next subsection will provide these instructions.</p>


      </google-codelab-step>

      <google-codelab-step label="Lab 4 Convert the Shellcode Into an Exe" duration="0">
        <p>Now you have the decrypted shellcode. This section will go over converting the shellcode into an executable so that you can view the disassembly in IDA.</p>
<p>Keep in mind that you don&#39;t need to do this step, but converting it into an executable will help you in debugging and understanding the deployed VM evasion techniques which are heavily discussed in the next section. You can open the decrypted_shellcode.bin in IDA and notice that the disassembly is not parsing functions properly. The malware author has inserted extraneous assembly instructions to through off malware analysis. <code>0x78</code> means assembly instruction <code>js</code> or <code>Jump short if sign (SF=1)</code>.</p>
<pre><code>00000000: 7878 7878 7878 7878 7878 7878 7878 7878  xxxxxxxxxxxxxxxx
00000010: 8b45 088b 4034 55e9 6761 0000 786a 6866  .E..@4U.ga..xjhf
00000020: 8995 34ff ffff 5a6a 7266 8995 36ff ffff  ..4...Zjrf..6...
00000030: 5ae9 2506 0000 7878 7878 7878 7878 7878  Z.%...xxxxxxxxxx
00000040: 7878 7878 7878 7858 6a74 6689 45c8 58e9  xxxxxxxXjtf.E.X.
00000050: 0229 0000 7878 7878 7878 7878 7878 7878  .)..xxxxxxxxxxxx
00000060: 7878 7878 7878 7889 5d88 e8af 3b00 0081  xxxxxxx.]...;...
...</code></pre>
<p>There are many tools and scripts available that help you convert shellcode into an exe like <a href="https://github.com/malware-unicorn/shellcode_tools/blob/master/shellcode2exe.py" target="_blank">shellcode2exe.py</a>. However I have found that Hexacon provided a nice easy <a href="http://www.hexacorn.com/blog/2015/12/10/converting-shellcode-to-portable-executable-32-and-64-bit/" target="_blank">tutorial for converting shellcode into an executable</a>. This section will be using this YASM and GoLink to create the executable while using CFF explorer to edit the binary header.</p>
<ol type="1" start="1">
<li>Download Yasm <a href="http://www.tortall.net/projects/yasm/releases/yasm-1.3.0-win32.exe" target="_blank">yasm-1.3.0-win32.exe</a></li>
<li>Extract yasm-1.3.0-win32.exe and rename it to yasm.exe</li>
<li>Download GoLink linker <a href="http://www.godevtool.com/Golink.zip" target="_blank">Golink.zip</a></li>
<li>Extract golink.exe</li>
<li>Create a decrypted_shellcode.asm file with the following instructions</li>
</ol>
<pre><code>Global Start
SECTION &#39;AyyLmao&#39; write, execute,read
Start:
incbin &#34;decrypted_shellcode.bin&#34; </code></pre>
<ol type="1" start="6">
<li>From a command line run the following command to assemble the code:</li>
</ol>
<pre><code>yasm.exe -f win32 -o decrypted_shellcode.obj decrypted_shellcode.asm</code></pre>
<ol type="1" start="7">
<li>Now run the linker</li>
</ol>
<pre><code>golink /ni /entry Start decrypted_shellcode.obj</code></pre>
<ol type="1" start="8">
<li>Open shellcode.exe with CFF explorer and open the NT Headers-&gt;Optional Headers-&gt;AddressOfEntryPoint. Add the current value to <code>0x42B7</code> which was the offset of where the malware was going to return to in function <code>sub_45B794</code>. AddressOfEntryPoint should be <code>000052B7</code>. This will ensure that IDA knows where to start the disassembly.</li>
</ol>


      </google-codelab-step>

      <google-codelab-step label="Lab 5 Evasion Techniques" duration="35">
        <p>This section will focus on identifying various evasion techniques as well as working around them during the debugging phase. Now that you will be working with a new executable, you will need to create another road map.</p>
<h2 is-upgraded>Control Flow Obfuscation</h2>
<p>You will notice that the shellcode is broken up into extraneous and unnecessary jumps. This is meant to throw off malware analysts. Malware that has this kind of useless instructions is usually processed with some kind of obfuscation kit (e.g., cryptors). Malware authors rarely write new shellcode and will sell, share, or reuse this code.</p>
<p>Going forward, you should be viewing the disassembly in graph mode, as it makes it easier to understand the control flow. Below is an example of the flow-chart mode of these jumps.</p>
<p class="image-container"><img style="width: 392.00px" src="../re102/img/c13af11e012c0d63.png"></p>
<h2 is-upgraded>Where to Start?</h2>
<p>There are no strings for us to investigate and there are no functions parsed by IDA. So, you need to start exploring each function one by one finding an interesting piece of code to analyze. This comes with experience. If this seems too daunting, then manual debugging is your next option. The goal is to make a road map of shellcode by working backwards.</p>
<h2 is-upgraded>String Obfuscation</h2>
<p>The first function call <code>sub_404C1E</code> doesn&#39;t look like something interesting, so move on to the next function call to <code>sub_402B1C</code>. This function is a jump-wrapper for the function <code>sub_4059A3</code>.</p>
<p>Notice anything strange about the immediate values being placed onto the stack? These are actually strings. Breaking up strings and pushing them onto the stack is a common of hiding strings from malware analysts. Go ahead right-click these numbers and convert it to a string (R).</p>
<p class="image-container"><img style="width: 528.00px" src="../re102/img/da5294a583e69f09.png"></p>
<p>They should look like this afterwards:</p>
<p class="image-container"><img style="width: 370.00px" src="../re102/img/499e38e97b8d085c.png"></p>
<h2 is-upgraded>Dynamic Library Loading</h2>
<p>With shellcode or position independent code (PIC), the code needs to load resources and libraries to work with before it performs the nefarious routines. Based on the strings above you can tell that it is going to load these libraries:</p>
<ul>
<li>user32</li>
<li>shell32</li>
<li>shlwapi</li>
<li>advapi32</li>
</ul>
<h2 is-upgraded>Access to the Process Environment Block (PEB)</h2>
<p>After the advapi32 string gets loaded onto the stack, enter the function <code>sub_405421</code>.</p>
<p>This function is accessing the FS segment register at offset 30. This register is commonly used by OS kernels to access thread-specific memory. This specific offset (i.e., <code>fs:[0x30]</code>) points to the Process Environment Block. This is a common shellcode tactic to get handles to loaded windows libraries a.k.a. Modules, specifically the base address of kernel32 from the PEB.</p>
<pre><code>mov     eax, 30h
mov     eax, fs:[eax] ; Get the address of PEB
mov     eax, [eax+0Ch] ; Get the address of PEB_LDR_DATA
mov     eax, [eax+0Ch] ; InLoadOrderModuleList
mov     eax, [eax] ; get the next entry
mov     eax, [eax+18h] ; get Kernel32</code></pre>
<p class="image-container"><img style="width: 413.50px" src="../re102/img/f9f00cb25b7e2c50.gif"></p>
<p>The second instruction <code>mov eax, [eax+0Ch]</code> gets the address of the PEB Loader Data from the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706%28v=vs.85%29.aspx" target="_blank">PEB</a> struct. The <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa813708(v=vs.85).aspx" target="_blank">PEB_LDR_DATA</a> contains the struct for the InMemoryOrderModuleList which is where it gets the pointer for Kernel32. </p>
<aside class="special"><p><strong>Note: </strong>There are many great shellcode resources available that explain this technique. I just want you to recognize the instruction fs:[0x30].</p>
</aside>
<pre><code>struct PEB_LDR_DATA {
    DWORD Length;                                       ; 0
    BYTE Initialized;                                   ; 4
    void* SsHandle;                                     ; 8
    struct LIST_ENTRY InLoadOrderModuleList;            ; 0ch
    struct LIST_ENTRY InMemoryOrderModuleList;          ; 14h
    struct LIST_ENTRY InInitializationOrderModuleList;  ; 1ch
};</code></pre>
<p>Save these functions <code>sub_402B1C</code> and <code>sub_405421</code> for debugging later. Also include these into your road map for the shellcode executable.</p>
<h2 is-upgraded>Checking the Filename and Path</h2>
<p>Go to the next function <code>sub_4014AA</code> which is a wrapper for function <code>sub_401D36</code>. Again, this function is using an anti-analysis technique of pushing a string one by one onto the stack. Can you guess what this function is doing?</p>
<p class="image-container"><img style="width: 364.00px" src="../re102/img/12f9bc6b3529d294.png"></p>
<p>The strings are:</p>
<ul>
<li>sample</li>
<li>sandbox</li>
<li>virus</li>
</ul>
<p>It seems the malware author wanted to detect if this executable contained strings related to malware analysis. You will need to debug this function to see which string it&#39;s comparing these values. You will want to avoid this function because you need to get around the anti-analysis detection. Remember that functions return 0 or 1 in eax depending on the success or failure. You want this function to fail or return 1 because you want to get around these traps. Below the instruction <code>cmp eax, 1</code> and <code>jz loc_405272</code> is where the comparison to the return value occurs. During debugging, you would want to force the jump by changing the EFlags.</p>
<p class="image-container"><img style="width: 294.00px" src="../re102/img/4260acd9774f0322.png"></p>
<h2 is-upgraded>Time to Start Debugging</h2>
<p>After jz <code>loc_405272</code> there is a call to [esp+1Ch] this is actually calling a Windows API call that was loaded there by the loaded library function <code>sub_402B1C</code>. It would be tedious to go through those locations by hand, so let&#39;s start debugging.</p>
<p class="image-container"><img style="width: 225.00px" src="../re102/img/4f7f4c710f21c9d2.png"></p>
<p>The next page will go over debugging the decrypted_shellcode.exe with x32dbg.</p>


      </google-codelab-step>

      <google-codelab-step label="Lab 6 Debugging Around Evasion" duration="45">
        <p>Debugging should be your last resort, as it can be time consuming. However, for the sake of teaching, I will go over it anyway. Be sure to take a snapshot of your VM before you begin debugging. This snapshot will come in handy when you accidentally run the malware sample.</p>
<aside class="special"><p><strong>Tip:</strong> Take frequent snapshots to save your debugging work, this way you won&#39;t lose your place.</p>
</aside>
<h2 is-upgraded>Create the Breakpoints</h2>
<p>Open decrypted_shellcode.exe in x32dbg.</p>
<p>At this point you should have recorded the following functions along with their corresponding locations:</p>
<ol type="1" start="1">
<li><code>sub_402B1C</code> @ <code>00401D9B</code> - The function that loads the libraries</li>
<li><code>sub_4014AA</code> @ <code>0040560B</code> - The function that checks for sample, sandbox, and virus</li>
<li><code>jz loc_405272</code> @ <code>004019E4</code> - The jump to modify the EFlags if necessary</li>
<li><code>jnz loc_405277</code> @ <code>0040526C</code> - The jump to modify the EFlags if necessary</li>
<li><code>loc_405272</code> @ <code>00405272</code> - The location that calls the unknown API</li>
<li><code>loc_405277</code> @ <code>00405277</code> - The location that calls the unknown API</li>
</ol>
<p>Place a breakpoint with x32dbg using the command line. Example: <code>bp 00401D9B</code></p>
<p class="image-container"><img style="width: 256.50px" src="../re102/img/89fec9318344b2e2.png"></p>
<p>Now press F9 to run the program to breakpoints until you reach <code>004019E4</code>.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/4ecc74016c77b8b1.png"></p>
<p>Scroll down to check out offset <code>00405272</code>. Looks like the <code>[esp+1C]</code> is using Path Windows APIs to check the strings against sample, sandbox, and virus. Since your exe name is and path does not contain these words, it will not take the jump. Thus, no need to change the flags or patch the instruction. Keep pressing F8 (to step over the instruction) until you reach the offset <code>00405277</code>.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/2a15f4e023801ffd.png"></p>
<p>Congrats! You bypassed the first evasion technique deployed by this malware . Now that you know what these API calls are, you should be renaming the subroutines in your IDA with appropriate labels.</p>
<h2 is-upgraded>Adding Resources</h2>
<p>Step <strong>F7 </strong>the program until you reach the next function <code>sub_40487D</code>. Be sure to record the arguments pushed onto the stack. Step Into <strong>F7 </strong>function <code>sub_40487D</code>. Next step until you reach <code>00401632</code> and look down to <code>00401645</code>. The calls to GetModuleHandle and FindResource indicate that the malware is about to access a resource.</p>
<p>This is typically how you get a resource from an exe:</p>
<pre><code>HMODULE hModule = GetModuleHandle(NULL); // get the handle to self (exe)
HRSRC hResource = FindResource(hModule, MAKEINTRESOURCE(RESOURCE_ID), RESOURCE_TYPE);
HGLOBAL hMemory = LoadResource(hModule, hResource);
DWORD dwSize = SizeofResource(hModule, hResource);
LPVOID lpAddress = LockResource(hMemory);</code></pre>
<p>When you turned the shellcode into an exe it did not include any resources. Remember that the original exe is where this shellcode gets executed. So, you will need to get the resource from the original exe and import them into shellcode exe. The argument passed to the function <code>sub_40487D</code> was 0xE38 which is 1000 in decimal. If you keep stepping through function <code>sub_40487D</code> you will see the routine above, and notice that the argument to find the resource is 1000.</p>
<pre><code>HRSRC WINAPI FindResource(
  _In_opt_ HMODULE hModule,
  _In_     LPCTSTR lpName, //ID of the resource
  _In_     LPCTSTR lpType
);</code></pre>
<p class="image-container"><img style="width: 347.50px" src="../re102/img/e3e6ca0e2c6df63d.png"></p>
<p>Close x32dbg while you edit the decrypted_shellcode.exe.</p>
<p>Open up the original exe in CFF explorer and look for the resource 1000. Next export this resource under Resource Editor, right-click and Save Resource (RAW). Take a moment and look at the data of this resource. Hint: looks like more junk data.</p>
<p class="image-container"><img style="width: 338.00px" src="../re102/img/ba5aae5088dc5269.png"></p>
<p>Once you exported the resource 1000, open the decrypted_shellcode.exe with CFF explorer. In the Resource Editor add Add Custom Resource (Raw) with the id of 1000. It should mirror the original exe. Afterwards open decrypted_shellcode.exe with x32dbg again. Navigate back to function <code>sub_40487D</code> or just set a breakpoint at <code>0040487D</code>and run until that function.</p>
<h2 is-upgraded>Saving Junk and Chunks in Memory</h2>
<p>Keep stepping until you reach <code>0040416F</code> where you will see that the resource is being placed into a new memory allocation. Remember that VirtualAlloc is typically followed by a ‘mov instruction&#39;. After the VirtualAlloc function is returned make sure you note the address of the newly allocated memory. As before, this function will put the address of the allocated memory in the <code>eax</code> register (the returned value).</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/9b736537ad86542e.png"></p>
<p>Once you are done stepping through function <code>sub_40487D</code> step until you reach <code>loc_4014C2</code>.</p>
<p class="image-container"><img style="width: 369.50px" src="../re102/img/6451b2529d3640d3.png"></p>
<p>The size 0x318 is a common theme for the next couple of function calls. This is where you will see another combo of VirtualAlloc and <code>mov</code>. It will store the first 0x318 bytes into the newly allocated memory.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/4cd10f836bdd55b0.png"></p>
<p class="image-container"><img style="width: 376.50px" src="../re102/img/538bc73fe79bdd43.png"></p>
<p>Does function <code>sub_403BC2</code> look familiar? Here is the breakdown:</p>
<pre><code>Arg_0 CopiedData+offset 20h
Arg_1 0x2F8 size
Arg_2 CopiedData
Arg_3 0x20 size</code></pre>
<p>Why offset 0x20? Here is the dump of the CopiedData:</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/d682e8948c1a0723.png"></p>
<p>At this point it&#39;s too early to guess what this data does.</p>
<pre><code>78 95 4D 26 0A C4 55 94 74 AF 5A 78 33 71 58 EB CD 05 B3 D6 5A B7 D6 05 43 D8 1A 7D 4A B6 EA 10</code></pre>
<p>In IDA, glance through function <code>sub_403BC2</code>. There are 3 hints that give away what this function is doing.</p>
<ul>
<li>The use of <code>0x100</code> and <code>0x20</code></li>
<li>Multiple loops</li>
<li>The use of XOR</li>
</ul>
<p>If you remember from the previous Lab 2, multiple loops and the use XOR is indicative of being some kind of crypto algorithm. There is a theme of crypto here, but there is just a slight difference. The use of anding a value with <code>800000FFh</code> is also a form of modulo for <code>X mod 256</code>. Earlier we saw that the modified RC4 algorithm was using a delphi mod function instead.</p>
<p>As you might have guessed, it looks like the malware is using RC4 again, but you might want to step through the algorithm to confirm if it&#39;s the correct RC4 or the modified RC4 like from Lab 2. Once you have, you will notice that the first 32 bytes (<code>0x20</code>) decrypted the rest of the CopiedData 760 bytes (<code>0x2F8</code>). Be sure to save the address of this memory in your notes, and rename the functions in IDA as you will need to go back to them for later in the workshop.</p>
<p>Step through until you reach <code>loc_401CCA</code> and continue to the next page.</p>


      </google-codelab-step>

      <google-codelab-step label="Lab 7 Evasion Techniques" duration="45">
        <h2 is-upgraded>Anti-Automation</h2>
<p>Before you continue to <code>loc_401CCA</code>, there were some Anti-Automation behaviors that were not discussed from earlier in the workshop. The calls to <code>GetForegroundWindow</code>, <code>Sleep</code>, and <code>GetForegroundWindow</code> indicate that the malware is deploying various anti-automation techniques to ensure that there is an actual user changing the state of the foreground window. Typically in automated sandbox testing there is no user interaction unless they accounted to build that into their VM.</p>
<p class="image-container"><img style="width: 284.50px" src="../re102/img/3bdf515ada433fef.png"></p>
<h2 is-upgraded>Anti-Debugging</h2>
<p>If you remember from earlier in the workshop, there were many calls to <code>OutputDebugString</code>. Instead of directly calling for <code>IsDebuggerPresent</code>, calling <code>OutputDebugString</code> and checking the success or failure is another technique to check if there is a debugger running. It&#39;s a simple tactic to make reverse engineering and debugging the malware harder.</p>
<h2 is-upgraded>VM Evasion</h2>
<p>There are many resources for a developer to identify if the process is running in a Virtual Machine. Paranoid Fish or pafish is one of the more well-known automated VM identification scripts available. You can view the code here: <a href="https://github.com/a0rtega/pafish" target="_blank">https://github.com/a0rtega/pafish</a>.</p>
<p>Every VM distro has their own filesystem and registry indicators. Products such as VMware and VirtualBox often have software installed to help with host to guest sharing. Hardware simulation will contain strings and naming related to the VM product. Some malware will change their behavior if they find out they are running inside a VM.</p>
<p>In IDA, start back at <code>loc_401CCA</code> where you will be able to identify some VM Evasion techniques.</p>
<h3 is-upgraded>Checking Hardware Device</h3>
<p>Earlier in this section, there was an anti-analysis technique of pushing strings to the stack. In function <code>sub_4029E7</code> until you are in function <code>sub_402274</code>, you can see that it is pushing H and A in the screenshot below.</p>
<p class="image-container"><img style="width: 403.50px" src="../re102/img/d425b381d7fd144e.gif"></p>
<p>Go ahead and go through all the strings that are being pushed to the stack. It should com out to:</p>
<p><code>HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id 0\ Logical Unit Id 0\Identifier</code></p>
<p>At the very end of the function it jumps to <code>loc_404777</code> where it calls <code>sub_403F73</code>. This is where the shellcode pushes strings vmware, qemu, and vbox. The malware is checking for registry artifacts to see if it&#39;s running inside a VM. In the debugger, set a breakpoint and run/step into <code>00406AB6</code> within function <code>sub_4037FD</code>. This is where the call to <code>RegOpenKeyEx</code> happens.</p>
<p class="image-container"><img style="width: 441.33px" src="../re102/img/651aa7bd59a35851.png"></p>
<p>If you follow the stack argument DWORD in the dump you can see the full strings. To view this, right click on the stack argument and select Follow <strong>DWORD in dump</strong>.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/89591d661ef76b1f.png"></p>
<p>Open regedit.exe in Windows and verify that this registry key exists under <code>HKEY_LOCAL_MACHINE</code>. If this key exists <code>RegOpenKeyEx</code> will return 0, if not 2. In the debugger, Step over F8 this function call. Fortunately this VM was built with an IDE instead of scsi hardware. You can verify this by looking at Virtualbox&#39;s storage settings.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/7f97c443854a994e.png"></p>
<p>If the VM you are working in does happen to have this registry key, you can always bypass the check. You can either get rid of the artifacts themselves or patch the binary. Put a breakpoint at <code>00404977</code> so that you won&#39;t miss this next jump. When you are debugging you can modify the ZF flag so that <code>jz loc_404D01</code> will fail and continue onto the next check.</p>
<p class="image-container"><img style="width: 427.50px" src="../re102/img/41fd57be4676bcce.png"></p>
<h3 is-upgraded>Check the System Bios</h3>
<p>Continue to step <strong>F7 </strong>to function <code>sub_4021FE</code> at <code>00404982</code>. This function is using the same anti-analysis technique by pushing strings onto the stack. The strings vbox and qemu are used to check the value in another registry key. Step through the rest of this function to reveal the full string until you reach <code>004047A7</code>.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/28154c01e24ad929.gif"></p>
<p>The registry key that you should have recovered from the stack is:</p>
<pre><code>HARDWARE\Description\System\SystemBiosVersion\SystemBiosVersion</code></pre>
<p>Verify in the registry using regedit.exe that this registry key exists. It looks like vbox does exist in the SystemBiosVersion string. You will need to modify the jumps in order to bypass this check in order to continue.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/a445c8b1b3c79946.png"></p>
<p>There are 2 places where you can choose to modify the jump:</p>
<ul>
<li>Right after the registry key check function:</li>
</ul>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/a453656d2f52ce0d.png"></p>
<ul>
<li>or Right after <code>sub_4021FE</code>:</li>
</ul>
<p class="image-container"><img style="width: 348.50px" src="../re102/img/cdb672846960d2e3.png"></p>
<p>If you modified either of the jump calls above while debugging you should have reached <code>loc_4010FE</code> and <code>sub_4029F1</code>. Below, you can see how to modify the second jump.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/1856ea7355e5621d.gif"></p>
<h3 is-upgraded>Check for VM drivers</h3>
<p>Just like the previous functions, the strings pushed to the stack. Look for the instruction <code>call dword ptr [ebx+0B0h]</code>which is where you set a breakpoint at <code>00405248</code>. In the debugger, this will call GetSystemDirectory which will return %system32%. Keep stepping through this function to get the full paths of the files it is checking for.</p>
<ul>
<li>%system32%\drivers\vmmouse.sys</li>
<li>%system32%\drivers\vmhgfs.sys</li>
<li>%system32%\drivers\VBoxMouse.sys</li>
<li>%system32%\drivers\VBoxGuest.sys</li>
</ul>
<p>Keep stepping through function <code>sub_4029F1</code> until you get back to <code>0040110B</code> where <code>jnz sub_401117</code> and force the jump to <code>sub_401117</code>.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/9e72a20f1a4ca6a7.gif"></p>
<h3 is-upgraded>Check for VM DLLs</h3>
<p>Step into <code>sub_401117</code> and keep going through instructions until you reach some interesting immediate values. Go ahead and convert the immediate values at <code>00405884</code> into strings.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/4847df4b5a843044.png"></p>
<p>This function is checking for sbiedll.dll which is a DLL used by the Sandboxie sandbox. If you are working with Vbox, this DLL will not exist so you won&#39;t need to bypass the jump. Keep working your way through this function because it&#39;s not done with all the checks.</p>
<h3 is-upgraded>Check the Physical Drive</h3>
<p>In IDA, look into <code>sub_406FCC</code> at <code>0040218D</code> after the sandboxie DLL check. Based on the logic below you might not need to step into this function. You can always force the jump to <code>loc_402192</code> and skip over <code>sub_406FCC</code>. For the purposes of recognizing VM evasion, you should step through this function.</p>
<p class="image-container"><img style="width: 415.50px" src="../re102/img/6c8b167cd798dade.png"></p>
<p>Put a breakpoint at <code>00404403</code> where the instruction <code>call dword ptr ds:[esi+98]</code> because this is the next API call. It tries to call CreateFile the PhysicalDrive0 in order to read it.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/a3f44ca134b79b16.png"></p>
<p>Because the above check failed, it will perform another device check. Keep stepping through the program until you reach 00406266 where the second API call is <code>call dword ptr ds:[esi+94]</code>. It is calling DeviceIoControl where it will check the \.\PhysicalDrive0 for the following strings:</p>
<ul>
<li>qm00001</li>
<li>virtual</li>
<li>array</li>
<li>vbox</li>
<li>vmware</li>
<li>00000000000000000001</li>
</ul>
<p>Here is the API function as reference:</p>
<pre><code>BOOL WINAPI DeviceIoControl(
  _In_        HANDLE       hDevice,
  _In_        DWORD        dwIoControlCode,
  _In_opt_    LPVOID       lpInBuffer,
  _In_        DWORD        nInBufferSize,
  _Out_opt_   LPVOID       lpOutBuffer,
  _In_        DWORD        nOutBufferSize,
  _Out_opt_   LPDWORD      lpBytesReturned,
  _Inout_opt_ LPOVERLAPPED lpOverlapped
);</code></pre>
<p>After DeviceIOControl is called do not take the jump after at <code>00405778</code> or <code>loc_405778</code>. This will cause the device to close and return back to the main function where the sandboxie DLL was checked.</p>
<p class="image-container"><img style="width: 454.00px" src="../re102/img/ce40bb1829dae6eb.png"></p>
<p>This jump should land you at <code>loc_402192</code> or <code>00402192</code>. Congratulations! You have made it past several VM evasion techniques. The next section will go over identifying a packer.</p>


      </google-codelab-step>

      <google-codelab-step label="Lab 8 Identifying Packing" duration="30">
        <p>This section will focus on identifying a custom packing routine. Believe it or not this whole shellcode executable is a packer itself. The next several functions will reveal its algorithm, and you will be able to create a simple unpacking script.</p>
<h2 is-upgraded>The Bat and Vbs Scripts</h2>
<p>Before you actually get to the unpacking routine, navigate your way to <code>loc_4050A0</code>. There is a function call you might miss. When you are debugging the jump instruction <code>jz loc_40196B</code> at <code>004050A0</code> will jump over <code>sub_405463</code>. If you want to debug this function just modify the jump here.</p>
<p class="image-container"><img style="width: 423.50px" src="../re102/img/74326dab455ea9a6.png"></p>
<p>Here is a summary of <code>sub_405463</code>:</p>
<ol type="1" start="1">
<li>This function allocates memory to store the current filename and <code>%APPDATA%</code> location to determine if the executable already exists there. The giveaways are:</li>
</ol>
<ul>
<li><code>VirtualAlloc</code></li>
<li><code>SHGetFolderPath</code></li>
<li><code>GetModuleHandleA</code></li>
<li><code>GetModuleFileNameW</code></li>
<li><code>PathRemoveFileSpec</code></li>
</ul>
<ol type="1" start="1">
<li>It will then try to create a process from the file stored in <code>%APPDATA%</code>, by calling CreateProcess</li>
<li>Create a .bat file in <code>%APPDATA%</code> where the contents are pushed onto the stack. This file contains the following:</li>
</ol>
<pre><code>start /d &#34;C:\Users\victim\AppData\&lt;exe filename&gt;&#34; </code></pre>
<ol type="1" start="3">
<li>Where it will write the hidden .vbs script in the location:</li>
</ol>
<pre><code>C:\\Users\\victim\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\&lt;filename&gt;.vbs</code></pre>
<p>This vbs script contains the following:</p>
<pre><code>Set WshShell = CreateObject(&#34;WScript.Shell&#34;)
WshShell.Run chr(34) &amp; &#34;C:\\Users\\victim\\AppData\\Roaming\\&lt;filename&gt;.bat&#34; &amp; Chr(34), 0
Set WshShell = Nothing</code></pre>
<p>To see the bat and vbs script get created, force these jump locations to not take the jump branch! This can be done like before, by simply changing the zero flag.</p>
<ul>
<li><code>00403089</code></li>
<li><code>00404652</code></li>
<li><code>004048A7</code></li>
<li><code>004048B0</code></li>
<li><code>00403349</code></li>
<li><code>0040507A</code></li>
</ul>
<h2 is-upgraded>The Unpacker</h2>
<p>In IDA, after the call to <code>sub_405463</code>, all paths lead to <code>loc_4057BC</code>. In the debugger, set a breakpoint at <code>004057BC</code> and run to this location.</p>
<p class="image-container"><img style="width: 381.50px" src="../re102/img/6ee58af1c3501b22.png"></p>
<p>The next routine should look familiar to you. There are multiple values being pushed to the stack before the call to <code>sub_40651A</code>.</p>
<p class="image-container"><img style="width: 416.42px" src="../re102/img/21db8ca2b5027833.png"></p>
<ol type="1" start="1">
<li>The first pushed value is <code>[esi+60]</code> which is the location where the first 0x318 bytes of Resource 1000 was decrypted.</li>
<li>The second value is 0x1.</li>
<li>The third pushed value is one dword at the relative offset <code>0x64</code> of that <code>0x318</code> bytes.</li>
<li>The fourth pushed value is one dword at the relative offset <code>0xA8</code> of that <code>0x318</code> bytes.</li>
<li>The fifth pushed value is the original resource stored in memory.</li>
</ol>
<p class="image-container"><img style="width: 521.00px" src="../re102/img/8910c58146b0a37.png"></p>
<p>The values for <code>0x0A</code> (10 decimal) and <code>0x21</code> (33 decimal) will become important within function <code>sub_40651A</code>. Step into <strong>F7</strong> function <code>sub_40651A</code>. The first part of the function allocates some memory where it will store the output of the next routine. In the debugger, step over <strong>F8 </strong>the VirtualAlloc call and dump the memory location that it returns so that you can monitor the changes.</p>
<p class="image-container"><img style="width: 382.00px" src="../re102/img/ab333036664c0658.png"></p>
<p>In the debugger, step <strong>F7 </strong>through this loop and keep track how values 10 and 33 are used against the resource bytes.</p>
<p class="image-container"><img style="width: 529.00px" src="../re102/img/34110ffa90fdd0e8.png"></p>
<p>The 2 dumps below shows what this routine is actually doing: compression. After the initial byte 0x1, it is removing every 10 bytes, displayed as <code>0xFF</code> below. The routine will then store the next 33 bytes.</p>
<p class="image-container"><img style="width: 522.00px" src="../re102/img/52a15e1f36790c76.gif"></p>
<p>Below is an example of what the first loop through the data looks like. All 10 instances of <code>0xFF</code> were removed.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/5bea26f492fbfec.png"></p>
<p>After you run through the whole function it will return this new compressed code for the next function call. Be sure to dump this section of memory as a .bin file and name it <em>compressed.bin</em>. You should have correctly renamed the RC4 function from earlier in IDA. After function <code>sub_40651A</code>, there should be a call to the RC4 decrypt function at <code>00407165</code>.</p>
<p class="image-container"><img style="width: 433.50px" src="../re102/img/4a014308f53ec280.png"></p>
<p>If you remember from earlier, the key size was <code>0x20</code>. For this call to RC4Decrypt, the key size is <code>0x40h</code> at offset <code>0x2D0</code> of the decrypted <code>0x318</code> bytes. Below is the RC4 key:</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/e03aea05e7dcb9b.png"></p>
<pre><code>6F 49 04 00 35 06 03 00 63 49 03 00 89 10 04 00 A2 6C 03 00 F4 D1 02 00 59 88 03 00 25 D4 03 00 74 EF 03 00 0B 6C 03 00 A8 95 03 00 E0 EC 02 00 75 52 04 00 2B FB 02 00 22 C4 03 00 B5 FF 02 00</code></pre>
<p>Export this key as a binary file and use the decrypt_shellcode.py script against the compressed.bin and the key.bin.</p>
<pre><code>c:\Python27\python.exe &lt;location&gt;\decrypt_shellcode.py  &lt;location&gt;0x40key.bin  &lt;location&gt;\compressed.bin</code></pre>
<p>In the debugger, you can step over <strong>F8 </strong>the RC4Decrypt function and watch the compressed code change to the output below:</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/7890bb535d06abb5.png"></p>
<p>Notice that the output looks like the header of a PE executable. The only difference is that it is missing the MZ header. If you scroll down after the RC4Decrypt function you will see the immediate value <code>0x544D</code> which is MZ. This is where it will add the MZ header.</p>
<p class="image-container"><img style="width: 462.50px" src="../re102/img/f3d7a876041bacd5.png"></p>
<p>Step through the rest until you reach a call to <code>sub_4031A9</code> at <code>00404C81</code>. You will find that it uses <code>CreateProcess</code> to spawn a new process of the newly created PE without dropping it to disk. After you step over the call to CreateProcess, you can open Process Explorer to view the newly created child process.</p>
<p class="image-container"><img style="width: 610.00px" src="../re102/img/c5a64c07bf5cf3fe.png"></p>
<p>Now that you know the algorithm, you can create an unpacking script for the resource. The next page will go over the script.</p>


      </google-codelab-step>

      <google-codelab-step label="Lab 8 The Unpacking Script" duration="1">
        <p>Here is the full unpacking script. Extract the raw resource <code>1000</code> as a binary file as the first argument. It will output the exe as decrypted_payload.exe.</p>
<pre><code>import os
import sys

# key sizes
key1size = 32  # 0x20
key2size = 64  # 0x40

# offset to key2
key2_offset = 720  # 2D0

# offset to payload
payload_offset = 792  # 0x318

# offset to first instruction
junk_char_length_offset = 100  # 0x64
good_char_length_offset = 168  # 0xA8

# header bytes
header = &#39;MZ&#39;


def key_schedule(_key):
    key = _key
    if not isinstance(_key, list):
        key = list(_key)
    keylength = len(key)
    S = range(256)
    j = 0
    for i in range(256):
        k = key[i % keylength]
        if not isinstance(key[i % keylength], int):
            k = ord(key[i % keylength])
        j = (j + S[i] + k) % 256
        S[i], S[j] = S[j], S[i]  # swap
    return S, j


def RC4_decrypt(_key, _enc):
    result = []
    S, j = key_schedule(_key)
    enc = _enc
    if not isinstance(_enc, list):
        enc = list(_enc)
    m = len(enc)
    i = 0
    for c in enc:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        k = S[(S[i] + S[j]) % 256]
        m -= 1
        if not isinstance(c, int):
            result.append(ord(c) ^ k)
        else:
            result.append(c ^ k)
    return result


def deflate_payload(junk, good_data, _data):
    data = list(_data)
    new_data = []
    j = 0
    k = 0
    new_data.append(ord(data[0]))
    i = 1
    while i &lt; len(data):
        if j != junk:
            j = junk
            i += j
        if j == junk:
            if k &lt; good_data:
                new_data.append(ord(data[i]))
                k += 1
                i += 1
            else:
                j = 0
                k = 0
    return new_data


with open(sys.argv[1], &#39;rb&#39;) as encrypted_file:

    # Get the file size
    file_size = os.path.getsize(sys.argv[1])

    # Get the first key of 0x20 bytes
    key1 = encrypted_file.read(key1size)

    # Get the start of deflate instructions
    encrypted_info = encrypted_file.read(payload_offset - key1size)

    # Get the bytes for the payload
    encrypted_payload = encrypted_file.read(file_size-payload_offset)

    # 1. Decrypt the deflation instructions
    decrypted_info = RC4_decrypt(key1, encrypted_info)

    # 2. Get instructions from the decrypted data
    junk_char_length = decrypted_info[junk_char_length_offset-key1size]
    good_char_length = decrypted_info[good_char_length_offset-key1size]

    # 3. deflate payload
    deflated_payload = deflate_payload(junk_char_length, good_char_length, encrypted_payload)

    # 4. get key2
    key2 = []
    for i in range(key2size):
        key2.append(decrypted_info[(key2_offset-key1size)+i])

    # 5. decrypt enc3
    decrypted_payload = RC4_decrypt(key2, deflated_payload)

    # 6. fix header
    for i in range(len(header)):
        decrypted_payload[i] = ord(header[i])

    # write to file
    with open(&#34;decrypted_payload.exe&#34;, &#39;wb&#39;) as out:
        for i in decrypted_payload:
            out.write(chr(i))
        out.close()</code></pre>


      </google-codelab-step>

      <google-codelab-step label="Extra Exercises" duration="1">
        <p>This concludes the workshop but you can apply the same unpacker to the resources in this malware. The payload exe is:</p>
<ol type="1" start="1">
<li>UPX packed</li>
<li>Has 3 resources using the same packer</li>
</ol>
<p>As an exercise, I recommend going through them on your own.</p>
<p>Most custom packers are bought and sold on underground forums or traded amongst malware authors. The following sample called <a href="https://en.wikipedia.org/wiki/Rombertik" target="_blank">Rombertik</a> uses this same packer. For fun you can check it out:</p>
<pre><code>77bacb44132eba894ff4cb9c8aa50c3e9c6a26a08f93168f65c48571fdf48e2a</code></pre>


      </google-codelab-step>

      <google-codelab-step label="Closing Remarks" duration="0">
        <p>This concludes workshop RE102. I hope you enjoyed the levels of obfuscation and evasion. Here is a summary of what the malware&#39;s packer does.</p>
<pre><code>8be8abab0f3ebcc18e7b8b3c437feb073fa7b9b30e8b1eef81451f0938b2a52a</code></pre>
<p>The purpose of this workshop was to get you familiar with Anti Reverse Engineering, Encryption, VM Evasion and Packing techniques. As you saw this malware&#39;s packer had multiple layers of shellcode and tricks to throw off a reverse engineer. But by breaking things down step by step, you were able to work your way through each challenge.</p>
<p>Special thanks to all my former interns.</p>


      </google-codelab-step>

  </google-codelab>

  <script src="../pkg/native-shim.js"></script>
  <script src="../pkg/custom-elements.min.js"></script>
  <script src="../pkg/prettify.js"></script>
  <script src="../pkg/codelab-elements.js"></script>

</body>
</html>
